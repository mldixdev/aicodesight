import { jsFindProjectRoot, jsLoadJSON } from './hookSharedSnippets';

/**
 * Generates pre-compact-save.js — fires before auto-compact to capture
 * working state from the transcript before context is summarized.
 */
export function generatePreCompactSave(): string {
  return `#!/usr/bin/env node
/**
 * pre-compact-save.js — PreCompact Hook
 * Generated by AICodeSight. Captures working state before auto-compact.
 *
 * Parses the transcript to extract:
 * - Files modified in the session
 * - Active TodoList (pending/completed tasks)
 * - Explicit decisions made
 * - Relevant session notes
 *
 * Saves everything to .claude/working-memory.json for post-compact restoration.
 */
const fs = require('fs');
const path = require('path');

let input = '';
process.stdin.setEncoding('utf-8');
process.stdin.on('data', (chunk) => { input += chunk; });
process.stdin.on('end', () => {
  try { run(JSON.parse(input)); }
  catch { process.exit(0); }
});
setTimeout(() => process.exit(0), 10000);

function run(context) {
  const projectRoot = findProjectRoot();
  if (!projectRoot) process.exit(0);

  const claudeDir = path.join(projectRoot, '.claude');
  const memoryPath = path.join(claudeDir, 'working-memory.json');
  const memory = loadJSON(memoryPath) || createEmptyMemory();

  // Parse transcript for state extraction
  const transcriptPath = context.transcript_path;
  if (transcriptPath && fs.existsSync(transcriptPath)) {
    try {
      const transcript = loadTranscript(transcriptPath);
      if (transcript) {
        extractStateFromTranscript(transcript, memory, projectRoot);
      }
    } catch { /* transcript may not be readable — non-critical */ }
  }

  // Extract active modules from recent changes
  updateActiveModules(memory, claudeDir);

  // Timestamp the save
  memory.lastUpdated = new Date().toISOString();
  memory._lastCompactSave = new Date().toISOString();

  // Trim to keep memory lean
  trimMemory(memory);

  // Update registry and pattern-index with lightweight regex extraction
  updateRegistryFromSession(memory, claudeDir);
  updatePatternIndexFromSession(memory, claudeDir);

  // Parse intent declarations from transcript and update capability-index
  if (transcriptPath && fs.existsSync(transcriptPath)) {
    try {
      const transcript = loadTranscript(transcriptPath);
      if (transcript) {
        const declarations = extractIntentDeclarations(transcript);
        updateCapabilityIndex(declarations, memory, claudeDir);
      }
    } catch { /* non-critical */ }
  }

  // Persist
  try {
    fs.writeFileSync(memoryPath, JSON.stringify(memory, null, 2), 'utf-8');
  } catch { /* non-critical */ }

  process.exit(0);
}

/**
 * Extracts working state from the Claude Code transcript.
 * JSONL format: each entry is {type, message: {role, content}, ...}
 * The actual message data is inside entry.message, not at the top level.
 */
function extractStateFromTranscript(transcript, memory, projectRoot) {
  if (!Array.isArray(transcript)) return;

  const modifiedFiles = new Set((memory.recentChanges || []).map(c => c.file));
  const readFiles = new Set(memory.filesRead || []);
  const bashCmds = memory.bashCommands || [];
  const decisions = memory.currentTask?.decisions || [];
  const notes = memory.sessionNotes || [];
  const sessionId = extractSessionId(transcript);

  for (const entry of transcript) {
    // JSONL entries wrap the message: {type, message: {role, content}, ...}
    const msg = entry.message || entry;
    if (!msg || !msg.role) continue;

    // Extract from tool_use blocks
    if (msg.role === 'assistant' && Array.isArray(msg.content)) {
      for (const block of msg.content) {
        if (block.type === 'tool_use') {
          const toolName = (block.name || '').toLowerCase();
          const toolInput = block.input || {};

          // Write/Edit operations
          if (toolName === 'write' || toolName === 'edit') {
            const filePath = toolInput.file_path || toolInput.filePath || '';
            if (filePath) {
              const rel = safeRelativePath(filePath, projectRoot);
              if (rel && !modifiedFiles.has(rel)) {
                modifiedFiles.add(rel);
                memory.recentChanges.push({
                  file: rel,
                  action: toolName,
                  session: sessionId,
                  timestamp: new Date().toISOString(),
                });
              }
            }
          }

          // Bash commands — capture the command string (truncated)
          if (toolName === 'bash') {
            const cmd = toolInput.command || '';
            if (cmd && cmd.length > 3) {
              bashCmds.push({
                command: cmd.substring(0, 200),
                timestamp: new Date().toISOString(),
              });
            }
          }

          // Read operations — capture which files were investigated
          if (toolName === 'read') {
            const filePath = toolInput.file_path || toolInput.filePath || '';
            if (filePath) {
              const rel = safeRelativePath(filePath, projectRoot);
              if (rel) readFiles.add(rel);
            }
          }

          // Grep/Glob — capture search patterns as session notes
          if (toolName === 'grep' || toolName === 'glob') {
            const pattern = toolInput.pattern || '';
            if (pattern) {
              notes.push('Search: ' + toolName + '("' + pattern.substring(0, 80) + '")');
            }
          }

          // TodoWrite state
          if (toolName === 'todowrite' && toolInput.todos) {
            extractTodoState(toolInput.todos, memory);
          }
        }
      }
    }

    // Extract decisions and notes from assistant text
    if (msg.role === 'assistant' && typeof msg.content === 'string') {
      extractDecisionsFromText(msg.content, decisions);
    }

    // Also handle content arrays with text blocks
    if (msg.role === 'assistant' && Array.isArray(msg.content)) {
      for (const block of msg.content) {
        if (block.type === 'text' && block.text) {
          extractDecisionsFromText(block.text, decisions);
        }
      }
    }
  }

  memory.bashCommands = bashCmds;
  memory.filesRead = [...readFiles];
  memory.sessionNotes = [...new Set(notes)]; // deduplicate

  if (memory.currentTask) {
    memory.currentTask.decisions = deduplicateDecisions(decisions);
  }
}

/**
 * Extracts task state from TodoWrite tool calls.
 */
function extractTodoState(todos, memory) {
  if (!Array.isArray(todos) || todos.length === 0) return;

  const inProgress = todos.filter(t => t.status === 'in_progress');
  const completed = todos.filter(t => t.status === 'completed');
  const pending = todos.filter(t => t.status === 'pending');

  memory.currentTask = memory.currentTask || {
    description: '',
    plan: [],
    completedSteps: [],
    decisions: [],
  };

  // Rebuild plan from all todos
  memory.currentTask.plan = todos.map(t => t.content);
  memory.currentTask.completedSteps = [];
  todos.forEach((t, i) => {
    if (t.status === 'completed') memory.currentTask.completedSteps.push(i);
  });

  // Set description from first in_progress or first pending
  if (inProgress.length > 0) {
    memory.currentTask.description = inProgress[0].content;
  } else if (pending.length > 0) {
    memory.currentTask.description = 'Pending: ' + pending[0].content;
  } else if (completed.length === todos.length) {
    memory.currentTask.description = 'All tasks completed';
  }
}

/**
 * Heuristic extraction of decisions from assistant text.
 * Looks for patterns like "decided to use X", "will use X instead of Y",
 * "discarded: X", "will use X because Y".
 */
function extractDecisionsFromText(text, decisions) {
  const decisionPatterns = [
    /(?:decided? to|will use|going to use|chose to use|using)\\s+(.{10,80})(?:\\s+(?:instead of|because|since|given that)\\s+(.{10,80}))?/gi,
    /(?:discarded|rejected|doesn't work|won't work|abandoned)[:\\s]+(.{10,80})/gi,
  ];

  for (const pattern of decisionPatterns) {
    let match;
    while ((match = pattern.exec(text)) !== null) {
      const what = match[1].trim().replace(/[.,:;]+$/, '');
      const why = match[2] ? match[2].trim().replace(/[.,:;]+$/, '') : '';
      if (what.length > 10 && what.length < 200) {
        decisions.push({
          what,
          why: why || 'detected in transcript',
          timestamp: new Date().toISOString(),
        });
      }
    }
  }
}

function deduplicateDecisions(decisions) {
  const seen = new Set();
  return decisions.filter(d => {
    const key = d.what.toLowerCase().substring(0, 50);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

/**
 * Updates activeModules based on which modules were touched in recentChanges.
 */
function updateActiveModules(memory, claudeDir) {
  try {
    const registry = loadJSON(path.join(claudeDir, 'registry.json'));
    if (!registry || !registry.modules) return;

    // Consider both modified and read files for active modules
    const touchedPaths = [
      ...(memory.recentChanges || []).map(c => c.file),
      ...(memory.filesRead || []),
    ];
    const activeModules = new Set(memory.activeModules || []);

    for (const [modulePath, _module] of Object.entries(registry.modules)) {
      if (touchedPaths.some(f => f.startsWith(modulePath))) {
        activeModules.add(modulePath);
      }
    }

    memory.activeModules = [...activeModules].slice(-10); // Keep last 10
  } catch { /* non-critical */ }
}

function trimMemory(memory) {
  // Keep only last 30 file changes
  if (memory.recentChanges && memory.recentChanges.length > 30) {
    memory.recentChanges = memory.recentChanges.slice(-30);
  }
  // Keep only last 20 bash commands
  if (memory.bashCommands && memory.bashCommands.length > 20) {
    memory.bashCommands = memory.bashCommands.slice(-20);
  }
  // Keep only last 20 files read
  if (memory.filesRead && memory.filesRead.length > 20) {
    memory.filesRead = memory.filesRead.slice(-20);
  }
  // Keep only last 10 rejected approaches
  if (memory.rejectedApproaches && memory.rejectedApproaches.length > 10) {
    memory.rejectedApproaches = memory.rejectedApproaches.slice(-10);
  }
  // Keep only last 15 decisions
  if (memory.currentTask && memory.currentTask.decisions && memory.currentTask.decisions.length > 15) {
    memory.currentTask.decisions = memory.currentTask.decisions.slice(-15);
  }
  // Keep only last 10 session notes
  if (memory.sessionNotes && memory.sessionNotes.length > 10) {
    memory.sessionNotes = memory.sessionNotes.slice(-10);
  }
}

function safeRelativePath(filePath, projectRoot) {
  try {
    const rel = path.relative(projectRoot, filePath).replace(/\\\\/g, '/');
    if (rel.startsWith('..')) return null;
    return rel;
  } catch { return null; }
}

function extractSessionId(transcript) {
  // Try to find session_id from context if available
  if (Array.isArray(transcript) && transcript.length > 0) {
    return 'session-' + new Date().toISOString().slice(0, 10);
  }
  return 'unknown';
}

${jsFindProjectRoot()}

function createEmptyMemory() {
  return {
    version: '1.1.0',
    lastUpdated: new Date().toISOString(),
    currentTask: null,
    recentChanges: [],
    bashCommands: [],
    filesRead: [],
    rejectedApproaches: [],
    activeModules: [],
    sessionNotes: [],
  };
}

${jsLoadJSON()}

// ── Lightweight Registry & Pattern Index Updates ────────────────────

function updateRegistryFromSession(memory, claudeDir) {
  const registryPath = path.join(claudeDir, 'registry.json');
  const SOURCE_EXTS = new Set(['.ts', '.tsx', '.js', '.jsx', '.cs']);

  try {
    let registry;
    try { registry = JSON.parse(fs.readFileSync(registryPath, 'utf-8')); }
    catch { registry = { version: 1, generatedAt: new Date().toISOString(), modules: {} }; }

    const recentFiles = (memory.recentChanges || [])
      .filter(c => SOURCE_EXTS.has(path.extname(c.file).toLowerCase()))
      .map(c => c.file);

    const uniqueFiles = [...new Set(recentFiles)];
    const filesToProcess = uniqueFiles.slice(-30);

    let updatedCount = 0;
    for (const relPath of filesToProcess) {
      const fullPath = path.join(path.dirname(claudeDir), relPath);
      if (!fs.existsSync(fullPath)) continue;

      let content;
      try { content = fs.readFileSync(fullPath, 'utf-8'); }
      catch { continue; }

      const exports = extractExportsRegex(content, relPath);
      if (exports.length === 0) continue;

      const modulePath = path.dirname(relPath);
      if (!registry.modules[modulePath]) {
        registry.modules[modulePath] = {
          path: modulePath, exports: [], fileCount: 0, totalLines: 0, dependsOn: []
        };
      }

      const mod = registry.modules[modulePath];
      mod.exports = (mod.exports || []).filter(e => e.file !== relPath);
      mod.exports.push(...exports.map(e => ({ ...e, file: relPath })));
      updatedCount++;
    }

    if (updatedCount > 0) {
      registry.generatedAt = new Date().toISOString();
      registry._updatedByHook = true;
      // Compact format: one export per line so Claude's Read tool can load the full file
      const lines = ['{'];
      lines.push('  "version": ' + JSON.stringify(registry.version) + ',');
      lines.push('  "generatedAt": ' + JSON.stringify(registry.generatedAt) + ',');
      if (registry._updatedByHook) lines.push('  "_updatedByHook": true,');
      lines.push('  "modules": {');
      const modKeys = Object.keys(registry.modules);
      for (let mi = 0; mi < modKeys.length; mi++) {
        const mod = registry.modules[modKeys[mi]];
        const mc = mi < modKeys.length - 1 ? ',' : '';
        lines.push('    ' + JSON.stringify(modKeys[mi]) + ': {');
        lines.push('      "type": ' + JSON.stringify(mod.type) + ',');
        if (mod.description) lines.push('      "description": ' + JSON.stringify(mod.description) + ',');
        if (mod.dependsOn && mod.dependsOn.length) lines.push('      "dependsOn": ' + JSON.stringify(mod.dependsOn) + ',');
        if (Array.isArray(mod.exports)) {
          lines.push('      "exports": [');
          for (let ei = 0; ei < mod.exports.length; ei++) {
            lines.push('        ' + JSON.stringify(mod.exports[ei]) + (ei < mod.exports.length - 1 ? ',' : ''));
          }
          lines.push('      ]');
        } else {
          lines.push('      "exports": {');
          const ek = Object.keys(mod.exports);
          for (let ei = 0; ei < ek.length; ei++) {
            lines.push('        ' + JSON.stringify(ek[ei]) + ': ' + JSON.stringify(mod.exports[ek[ei]]) + (ei < ek.length - 1 ? ',' : ''));
          }
          lines.push('      }');
        }
        lines.push('    }' + mc);
      }
      lines.push('  },');
      const unmapped = registry.unmapped || {};
      const uk = Object.keys(unmapped);
      if (uk.length > 0) {
        lines.push('  "unmapped": {');
        for (let ui = 0; ui < uk.length; ui++) {
          lines.push('    ' + JSON.stringify(uk[ui]) + ': ' + JSON.stringify(unmapped[uk[ui]]) + (ui < uk.length - 1 ? ',' : ''));
        }
        lines.push('  }');
      } else {
        lines.push('  "unmapped": {}');
      }
      lines.push('}');
      fs.writeFileSync(registryPath, lines.join('\\n') + '\\n', 'utf-8');
    }

    memory._sessionFileCount = uniqueFiles.length;
  } catch (err) {
    if (process.env.DEBUG) console.error('Registry update failed:', err.message);
  }
}

function extractExportsRegex(content, filePath) {
  const exports = [];
  const ext = path.extname(filePath).toLowerCase();
  const lines = content.split('\\n');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineNum = i + 1;

    if (ext === '.cs') {
      const csMatch = line.match(
        /^\\s*public\\s+(?:(?:static|abstract|sealed|partial)\\s+)*(class|interface|enum|record|struct)\\s+(\\w+)/
      );
      if (csMatch) exports.push({ name: csMatch[2], type: csMatch[1], line: lineNum });

      const methodMatch = line.match(
        /^\\s*public\\s+(?:(?:static|async|virtual|override)\\s+)*\\w[\\w<>\\[\\]?]*\\s+(\\w+)\\s*\\(/
      );
      if (methodMatch && !['if','while','for','switch'].includes(methodMatch[1]))
        exports.push({ name: methodMatch[1], type: 'method', line: lineNum });
    } else {
      const tsMatch = line.match(
        /^export\\s+(?:default\\s+)?(?:async\\s+)?(function|const|let|class|interface|type|enum)\\s+(\\w+)/
      );
      if (tsMatch) exports.push({ name: tsMatch[2], type: tsMatch[1], line: lineNum });

      const namedMatch = line.match(/^export\\s*\\{([^}]+)\\}/);
      if (namedMatch) {
        const names = namedMatch[1].split(',').map(n => n.trim().split(/\\s+as\\s+/).pop().trim());
        for (const name of names) {
          if (name) exports.push({ name, type: 'export', line: lineNum });
        }
      }
    }
  }
  return exports;
}

function updatePatternIndexFromSession(memory, claudeDir) {
  const indexPath = path.join(claudeDir, 'pattern-index.json');
  const SOURCE_EXTS = new Set(['.ts', '.tsx', '.js', '.jsx', '.cs']);
  const WINDOW = 4;

  try {
    let index;
    try { index = JSON.parse(fs.readFileSync(indexPath, 'utf-8')); }
    catch { index = { version: 1, generatedAt: new Date().toISOString(), windowSize: WINDOW, fingerprints: {} }; }

    const recentFiles = (memory.recentChanges || [])
      .filter(c => SOURCE_EXTS.has(path.extname(c.file).toLowerCase()))
      .map(c => c.file);
    const uniqueFiles = [...new Set(recentFiles)].slice(-30);

    let updatedCount = 0;
    for (const relPath of uniqueFiles) {
      const fullPath = path.join(path.dirname(claudeDir), relPath);
      if (!fs.existsSync(fullPath)) continue;

      let content;
      try { content = fs.readFileSync(fullPath, 'utf-8'); }
      catch { continue; }

      const lines = content.split('\\n');
      if (lines.length > 500) continue;

      // Remove old fingerprints for this file
      for (const hash of Object.keys(index.fingerprints)) {
        const entry = index.fingerprints[hash];
        entry.locations = entry.locations.filter(l => l.file !== relPath);
        if (entry.locations.length < 2) delete index.fingerprints[hash];
      }

      // Generate new fingerprints
      const meaningful = [];
      for (let i = 0; i < lines.length; i++) {
        const trimmed = lines[i].trim();
        if (isTrivialLine(trimmed)) continue;
        const norm = normalizeLine(lines[i]);
        if (norm.length < 5) continue;
        meaningful.push({ normalized: norm, originalLine: i + 1 });
      }

      for (let i = 0; i <= meaningful.length - WINDOW; i++) {
        const windowLines = meaningful.slice(i, i + WINDOW);
        const key = windowLines.map(m => m.normalized).join('|');
        const hash = simpleHash(key);

        if (!index.fingerprints[hash]) {
          index.fingerprints[hash] = { normalized: key, locations: [] };
        }

        const entry = index.fingerprints[hash];
        if (entry.locations.length >= 10) continue;

        const alreadyHas = entry.locations.some(
          l => l.file === relPath && Math.abs(l.line - windowLines[0].originalLine) < WINDOW
        );
        if (!alreadyHas) {
          entry.locations.push({ file: relPath, line: windowLines[0].originalLine });
        }
      }
      updatedCount++;
    }

    // Prune: keep only fingerprints with 2+ locations
    for (const hash of Object.keys(index.fingerprints)) {
      if (index.fingerprints[hash].locations.length < 2) {
        delete index.fingerprints[hash];
      }
    }

    if (updatedCount > 0) {
      index.generatedAt = new Date().toISOString();
      index._updatedByHook = true;
      fs.writeFileSync(indexPath, JSON.stringify(index, null, 2), 'utf-8');
    }
  } catch (err) {
    if (process.env.DEBUG) console.error('Pattern index update failed:', err.message);
  }
}

function normalizeLine(line) {
  return line
    .replace(/\\/\\/.*$/, '')
    .replace(/\\/\\*.*?\\*\\//g, '')
    .replace(/['"][^'"]*['"]/g, '""')
    .replace(/\\b\\d+\\b/g, '0')
    .replace(/\\s+/g, ' ')
    .trim()
    .toLowerCase();
}

function isTrivialLine(line) {
  if (!line || line.length < 3) return true;
  if (/^[\\/{})\\];,]*$/.test(line)) return true;
  if (/^(import|using|require|from)\\b/.test(line)) return true;
  if (/^\\/\\//.test(line) || /^\\/\\*/.test(line) || /^\\*/.test(line)) return true;
  return false;
}

function simpleHash(str) {
  let hash = 5381;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash + str.charCodeAt(i)) & 0x7fffffff;
  }
  return hash.toString(36);
}

/**
 * Loads a transcript file. Supports both .json (array) and .jsonl (one JSON per line).
 * Returns an array of message objects or null.
 */
function loadTranscript(filePath) {
  try {
    const raw = fs.readFileSync(filePath, 'utf-8');
    // Try standard JSON first
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return parsed;
      return [parsed];
    } catch { /* not valid JSON, try JSONL */ }

    // Parse as JSONL (one JSON object per line)
    const messages = [];
    for (const line of raw.split('\\n')) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      try { messages.push(JSON.parse(trimmed)); }
      catch { /* skip malformed lines */ }
    }
    return messages.length > 0 ? messages : null;
  } catch { return null; }
}

// ── Intent Declaration Parsing ──────────────────────────────────────

/**
 * Extracts intent declarations from the transcript.
 * Looks for blocks with FILE/INTENT/DOMAIN/ACTION/ENTITY/DEPENDS_ON
 * in assistant messages (text content).
 */
function extractIntentDeclarations(transcript) {
  if (!Array.isArray(transcript)) return [];

  const declarations = [];

  for (const entry of transcript) {
    const msg = entry.message || entry;
    if (!msg || msg.role !== 'assistant') continue;

    // Collect all text from this message
    let textContent = '';
    if (typeof msg.content === 'string') {
      textContent = msg.content;
    } else if (Array.isArray(msg.content)) {
      for (const block of msg.content) {
        if (block.type === 'text' && block.text) {
          textContent += block.text + '\\n';
        }
      }
    }
    if (!textContent) continue;

    // Parse declaration blocks
    const fileRegex = /^FILE:\\s*(.+)$/gm;
    let match;
    while ((match = fileRegex.exec(textContent)) !== null) {
      const filePath = match[1].trim();
      const startIdx = match.index;

      // Look for the other fields within 500 chars after FILE
      const region = textContent.substring(startIdx, startIdx + 500);

      const intentMatch = region.match(/^INTENT:\\s*(.+)$/m);
      const domainMatch = region.match(/^DOMAIN:\\s*(.+)$/m);
      const actionMatch = region.match(/^ACTION:\\s*(.+)$/m);
      const entityMatch = region.match(/^ENTITY:\\s*(.+)$/m);
      const dependsMatch = region.match(/^DEPENDS_ON:\\s*\\[(.+)\\]$/m);

      // Require at least FILE + INTENT for a valid declaration
      if (intentMatch) {
        declarations.push({
          file: filePath,
          description: intentMatch[1].trim(),
          domain: domainMatch ? domainMatch[1].trim().toLowerCase() : null,
          action: actionMatch ? actionMatch[1].trim().toLowerCase() : null,
          entity: entityMatch ? entityMatch[1].trim().toLowerCase() : null,
          dependsOn: dependsMatch
            ? dependsMatch[1].split(',').map(d => d.trim()).filter(Boolean)
            : null,
        });
      }
    }
  }

  return declarations;
}

/**
 * Updates capability-index.json with intent declarations and reconciliation.
 *
 * 1. Load existing capability-index.json
 * 2. Merge declarations (add or update entries as "declared")
 * 3. Reconciliation: scan source files for exports not in the index
 * 4. Save updated index
 */
function updateCapabilityIndex(declarations, memory, claudeDir) {
  const indexPath = path.join(claudeDir, 'capability-index.json');
  const projectRoot = path.dirname(claudeDir);
  const SOURCE_EXTS = new Set(['.ts', '.tsx', '.js', '.jsx', '.cs']);

  try {
    let index;
    try { index = JSON.parse(fs.readFileSync(indexPath, 'utf-8')); }
    catch {
      index = { version: '2.0', generatedAt: new Date().toISOString(), source: 'static', entries: [] };
    }

    // Ensure entries array exists
    if (!Array.isArray(index.entries)) index.entries = [];

    let changed = false;

    // 1. Merge intent declarations
    for (const decl of declarations) {
      const normalizedFile = decl.file.replace(/\\\\/g, '/');
      const existing = index.entries.find(
        e => e.file.replace(/\\\\/g, '/') === normalizedFile
      );

      if (existing) {
        // Update existing entry with declared intent
        existing.description = decl.description;
        existing.domain = decl.domain;
        existing.action = decl.action;
        existing.entity = decl.entity;
        existing.dependsOn = decl.dependsOn;
        existing.source = 'declared';
        changed = true;
      } else {
        // Add new declared entry
        index.entries.push({
          name: path.basename(normalizedFile, path.extname(normalizedFile)),
          type: 'function',
          file: normalizedFile,
          line: 1,
          signatureShape: 'unknown',
          effects: [],
          description: decl.description,
          domain: decl.domain,
          action: decl.action,
          entity: decl.entity,
          dependsOn: decl.dependsOn,
          source: 'declared',
        });
        changed = true;
      }
    }

    // 2. Reconciliation: scan recently modified files for new exports
    const recentFiles = (memory.recentChanges || [])
      .filter(c => SOURCE_EXTS.has(path.extname(c.file).toLowerCase()))
      .map(c => c.file);
    const uniqueFiles = [...new Set(recentFiles)];

    for (const relPath of uniqueFiles) {
      const fullPath = path.join(projectRoot, relPath);
      if (!fs.existsSync(fullPath)) continue;

      let content;
      try { content = fs.readFileSync(fullPath, 'utf-8'); }
      catch { continue; }

      const exports = extractExportsRegex(content, relPath);
      const normalizedRel = relPath.replace(/\\\\/g, '/');

      for (const exp of exports) {
        const alreadyExists = index.entries.some(
          e => e.name === exp.name && e.file.replace(/\\\\/g, '/') === normalizedRel
        );

        if (!alreadyExists) {
          index.entries.push({
            name: exp.name,
            type: exp.type || 'function',
            file: normalizedRel,
            line: exp.line || 1,
            signatureShape: 'unknown',
            effects: [],
            description: null,
            domain: null,
            action: null,
            entity: null,
            dependsOn: null,
            source: 'extracted',
          });
          changed = true;
        }
      }
    }

    if (changed) {
      index.generatedAt = new Date().toISOString();
      index.source = declarations.length > 0 ? 'hybrid' : index.source;
      index._updatedByHook = true;
      // Compact format: one entry per line so Claude's Read tool can load the full file in one pass
      const lines = ['{'];
      lines.push('  "version": ' + JSON.stringify(index.version) + ',');
      lines.push('  "generatedAt": ' + JSON.stringify(index.generatedAt) + ',');
      lines.push('  "source": ' + JSON.stringify(index.source) + ',');
      if (index._updatedByHook) lines.push('  "_updatedByHook": true,');
      lines.push('  "entries": [');
      const last = index.entries.length - 1;
      for (let i = 0; i < index.entries.length; i++) {
        lines.push('    ' + JSON.stringify(index.entries[i]) + (i < last ? ',' : ''));
      }
      lines.push('  ]');
      lines.push('}');
      fs.writeFileSync(indexPath, lines.join('\\n') + '\\n', 'utf-8');
    }
  } catch (err) {
    if (process.env.DEBUG) console.error('Capability index update failed:', err.message);
  }
}
`;
}
