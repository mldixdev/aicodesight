import { jsFindProjectRoot, jsLoadJSON } from './hookSharedSnippets';

/**
 * Generates compact-restore.js — fires on SessionStart when source is "compact".
 * Reads working-memory.json and injects relevant context via additionalContext.
 * Also performs registry slicing: only injects modules relevant to active work.
 */
export function generateCompactRestore(): string {
  return `#!/usr/bin/env node
/**
 * compact-restore.js — SessionStart("compact") Hook
 * Generated by AICodeSight. Restores working context after auto-compact.
 *
 * Reads .claude/working-memory.json and generates additionalContext with:
 * - Current task and progress
 * - Recently modified files
 * - Decisions made in the session
 * - Relevant registry slice (only active modules)
 * - Rejected approaches (to avoid repeating mistakes)
 */
const fs = require('fs');
const path = require('path');

let input = '';
process.stdin.setEncoding('utf-8');
process.stdin.on('data', (chunk) => { input += chunk; });
process.stdin.on('end', () => {
  try { run(JSON.parse(input)); }
  catch { outputEmpty(); }
});
setTimeout(() => outputEmpty(), 8000);

function run(context) {
  const projectRoot = findProjectRoot();
  if (!projectRoot) { outputEmpty(); return; }

  const claudeDir = path.join(projectRoot, '.claude');

  // --- Layer 2: Verify aicodesight hooks exist in settings.json ---
  verifyHooks(claudeDir);

  const memory = loadJSON(path.join(claudeDir, 'working-memory.json'));

  if (!memory) { outputEmpty(); return; }

  const sections = [];

  // 1. Current task and progress
  if (memory.currentTask && memory.currentTask.description) {
    sections.push(formatCurrentTask(memory.currentTask));
  }

  // 2. Recent file changes
  if (memory.recentChanges && memory.recentChanges.length > 0) {
    sections.push(formatRecentChanges(memory.recentChanges));
  }

  // 3. Decisions made
  if (memory.currentTask?.decisions?.length > 0) {
    sections.push(formatDecisions(memory.currentTask.decisions));
  }

  // 4. Bash commands executed
  if (memory.bashCommands && memory.bashCommands.length > 0) {
    sections.push(formatBashCommands(memory.bashCommands));
  }

  // 5. Files investigated (read)
  if (memory.filesRead && memory.filesRead.length > 0) {
    sections.push(formatFilesRead(memory.filesRead));
  }

  // 6. Rejected approaches
  if (memory.rejectedApproaches && memory.rejectedApproaches.length > 0) {
    sections.push(formatRejected(memory.rejectedApproaches));
  }

  // 7. Registry slice (only active modules)
  if (memory.activeModules && memory.activeModules.length > 0) {
    const registrySlice = getRegistrySlice(claudeDir, memory.activeModules);
    if (registrySlice) {
      sections.push(registrySlice);
    }
  }

  // 8. Session notes
  if (memory.sessionNotes && memory.sessionNotes.length > 0) {
    sections.push(formatNotes(memory.sessionNotes));
  }

  // 9. Stale artifacts warning
  const staleWarning = checkStaleArtifacts(claudeDir, memory);
  if (staleWarning) sections.push(staleWarning);

  if (sections.length === 0) { outputEmpty(); return; }

  const additionalContext = [
    '## Restored State Post-Compact (AICodeSight working memory)',
    '',
    'This context was automatically saved before auto-compact.',
    'See .claude/working-memory.json for full details.',
    'See .claude/registry.json if you need signatures of modules not listed here.',
    '',
    ...sections,
  ].join('\\n');

  const output = {
    hookSpecificOutput: {
      hookEventName: 'SessionStart',
      additionalContext,
    },
  };

  process.stdout.write(JSON.stringify(output));
  process.exit(0);
}

function formatCurrentTask(task) {
  const lines = ['### Current Task', ''];

  if (task.description) {
    lines.push('**In progress:** ' + task.description);
    lines.push('');
  }

  if (task.plan && task.plan.length > 0) {
    lines.push('**Plan:**');
    const completed = new Set(task.completedSteps || []);
    task.plan.forEach((step, i) => {
      const mark = completed.has(i) ? '[x]' : '[ ]';
      lines.push('- ' + mark + ' ' + step);
    });
    lines.push('');
  }

  return lines.join('\\n');
}

function formatRecentChanges(changes) {
  // Deduplicate and show last 15
  const unique = [];
  const seen = new Set();
  for (const c of changes.slice(-15)) {
    if (!seen.has(c.file)) {
      seen.add(c.file);
      unique.push(c);
    }
  }

  const lines = ['### Files Modified in this Session', ''];
  for (const c of unique) {
    lines.push('- \`' + c.file + '\` (' + c.action + ')');
  }
  lines.push('');
  return lines.join('\\n');
}

function formatBashCommands(commands) {
  // Show last 10 unique commands
  const unique = [];
  const seen = new Set();
  for (const c of commands.slice(-10)) {
    const key = c.command.substring(0, 80);
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(c);
    }
  }

  const lines = ['### Commands Executed', ''];
  for (const c of unique) {
    lines.push('- \`' + c.command.replace(/\`/g, "'") + '\`');
  }
  lines.push('');
  return lines.join('\\n');
}

function formatFilesRead(files) {
  const unique = [...new Set(files)].slice(-15);
  const lines = ['### Files Investigated (Read)', ''];
  for (const f of unique) {
    lines.push('- \`' + f + '\`');
  }
  lines.push('');
  return lines.join('\\n');
}

function formatDecisions(decisions) {
  const lines = ['### Decisions Made', ''];
  for (const d of decisions.slice(-8)) {
    lines.push('- **' + d.what + '**' + (d.why ? ' — ' + d.why : ''));
  }
  lines.push('');
  return lines.join('\\n');
}

function formatRejected(rejected) {
  const lines = ['### Rejected Approaches (DO NOT repeat)', ''];
  for (const r of rejected.slice(-5)) {
    lines.push('- ' + r);
  }
  lines.push('');
  return lines.join('\\n');
}

function formatNotes(notes) {
  const lines = ['### Session Notes', ''];
  for (const n of notes.slice(-5)) {
    lines.push('- ' + n);
  }
  lines.push('');
  return lines.join('\\n');
}

/**
 * Registry slicing: loads the full registry but returns only modules
 * that were actively being worked on (detected via activeModules).
 * This saves context by not injecting the entire registry post-compact.
 */
function getRegistrySlice(claudeDir, activeModules) {
  const registry = loadJSON(path.join(claudeDir, 'registry.json'));
  if (!registry || !registry.modules) return null;

  const lines = ['### Relevant Modules (registry slice)', ''];

  for (const modulePath of activeModules) {
    const mod = registry.modules[modulePath];
    if (!mod) continue;

    const desc = mod.description ? ' — ' + mod.description : '';
    lines.push('**' + modulePath + '**' + desc);

    if (mod.exports) {
      const exportNames = Object.keys(mod.exports).slice(0, 15);
      for (const name of exportNames) {
        const exp = mod.exports[name];
        const sig = exp.signature ? ': \`' + exp.signature.substring(0, 100) + '\`' : '';
        lines.push('  - ' + name + ' (' + exp.type + ')' + sig);
      }
    }
    lines.push('');
  }

  return lines.length > 2 ? lines.join('\\n') : null;
}

/**
 * Verifies that aicodesight hooks exist in settings.json.
 * If missing, loads restore-settings.js and runs it to recover them.
 * This is Layer 2 of the hooks persistence strategy.
 */
function verifyHooks(claudeDir) {
  try {
    const settingsPath = path.join(claudeDir, 'settings.json');
    const settings = loadJSON(settingsPath);
    if (!settings || !settings.hooks) {
      runRestore(claudeDir);
      return;
    }

    // Check if at least one aicodesight hook exists
    const allMatchers = Object.values(settings.hooks).flat();
    const hasHooks = allMatchers.some(m => m && m._source === 'aicodesight');
    if (!hasHooks) {
      runRestore(claudeDir);
    }
  } catch {
    // If anything fails, try restore silently
    try { runRestore(claudeDir); } catch {}
  }
}

function runRestore(claudeDir) {
  const restorePath = path.join(claudeDir, 'hooks', 'restore-settings.js');
  if (fs.existsSync(restorePath)) {
    try {
      const { main } = require(restorePath);
      if (typeof main === 'function') main();
    } catch {
      // Fallback: run as child process
      try {
        require('child_process').execSync('node "' + restorePath + '"', { stdio: 'ignore', timeout: 5000 });
      } catch {}
    }
  }
}

function outputEmpty() {
  process.stdout.write(JSON.stringify({}));
  process.exit(0);
}

${jsFindProjectRoot()}

function checkStaleArtifacts(claudeDir, memory) {
  try {
    const inventory = loadJSON(path.join(claudeDir, 'inventory.json'));
    const recentWrites = (memory.recentChanges || [])
      .filter(c => c.action === 'write')
      .length;
    const inventoryCount = inventory?.stats?.totalFiles || 0;

    if (recentWrites > Math.max(10, inventoryCount * 0.5)) {
      return '### WARNING: Potentially Stale Artifacts\\n\\n' +
        recentWrites + ' files have been created/modified in this session.\\n' +
        'registry.json and pattern-index.json were partially updated (exports via regex).\\n' +
        'REQUIRED: Run the full anti-duplication protocol (steps 0-4) before creating new files.\\n' +
        'SUGGESTION for user: run \`npx aicodesight update\` for complete data.\\n';
    }
  } catch { /* non-critical */ }
  return null;
}

${jsLoadJSON()}
`;
}
