/**
 * Generates structural-duplication.js guard — detects repeated code patterns
 * within a file using structural normalization (not just export names).
 *
 * Phase 1: Intra-file detection with 7 pattern detectors.
 * Phase 2 (future): Cross-file fingerprinting via pattern-index.json.
 */
export function generateStructuralGuard(): string {
  return `/**
 * structural-duplication.js — Guard: Repeated structural pattern detection
 * Generated by AICodeSight. Detects duplication that the name-based guard cannot see.
 */
module.exports = {
  name: 'structural-duplication',

  check(ctx) {
    if (!ctx.content) return { passed: true, messages: [] };
    const config = ctx.config.guards['structural-duplication'] || {};
    if (config.severity === 'off') return { passed: true, messages: [] };

    const lines = ctx.content.split('\\n');
    // Short-circuit for very large files (perf safety)
    if (lines.length > 2000) return { passed: true, messages: [] };

    const ext = ctx.ext || '';
    const thresholds = config.thresholds || {};
    const disabled = new Set(config.disabledDetectors || []);
    const severity = config.severity || 'info';

    const detectors = [
      { name: 'useQuery', fn: repeatedQueryPattern },
      { name: 'className', fn: repeatedClassName },
      { name: 'httpCalls', fn: repeatedHttpCalls },
      { name: 'formFields', fn: repeatedFormFields },
      { name: 'endpoints', fn: repeatedEndpoints },
      { name: 'switchBranches', fn: repeatedSwitchBranches },
      { name: 'tryCatch', fn: repeatedTryCatch },
    ];

    const messages = [];
    for (const detector of detectors) {
      if (disabled.has(detector.name)) continue;
      const threshold = thresholds[detector.name] || getDefaultThreshold(detector.name);
      const hits = detector.fn(lines, ext, threshold, severity);
      messages.push(...hits);
    }

    // Phase 2: Cross-file fingerprint matching
    if (!disabled.has('crossFile')) {
      const crossFileHits = checkCrossFilePatterns(lines, ext, ctx, severity);
      messages.push(...crossFileHits);
    }

    return {
      passed: messages.every(m => m.severity !== 'block'),
      messages,
    };
  },
};

// ── Helpers ──────────────────────────────────────────────────

function getDefaultThreshold(name) {
  const defaults = {
    useQuery: 3, className: 3, httpCalls: 3,
    formFields: 4, endpoints: 3, switchBranches: 4, tryCatch: 3,
  };
  return defaults[name] || 3;
}

/**
 * Normalize a line for structural comparison:
 * - Replace string literals with placeholder
 * - Replace numbers with placeholder
 * - Replace all identifiers with placeholder (preserve language keywords)
 */
function normalize(line) {
  const KEYWORDS = new Set([
    'const','let','var','function','return','if','else','for','while','do',
    'switch','case','break','default','try','catch','finally','throw','new',
    'class','extends','import','export','from','async','await','yield',
    'typeof','instanceof','in','of','null','undefined','true','false','this',
    'void','delete','static','get','set','super','interface','type','enum',
    'public','private','protected','readonly','abstract','override','virtual',
    'using','namespace','partial','sealed','internal','string','int','bool',
    'var','object','dynamic','decimal','double','float','long','byte','Task',
    'Promise','Array','Map','Set','Record','Partial','Required','Omit','Pick',
  ]);
  return line
    .trim()
    .replace(/\\/\\/.*$/, '')                           // strip line comments
    .replace(/'[^']*'/g, '"_STR_"')                     // single-quoted strings
    .replace(/"[^"]*"/g, '"_STR_"')                     // double-quoted strings
    .replace(/\`[^\`]*\`/g, '"_STR_"')                  // template literals (single-line)
    .replace(/\\b\\d+(\\.\\d+)?\\b/g, '_NUM_')          // numbers
    .replace(/\\b[a-zA-Z_$][a-zA-Z0-9_$]*\\b/g, (m) => // all identifiers (camel, Pascal, snake)
      KEYWORDS.has(m) ? m : '_ID_'
    )
    .replace(/\\s+/g, ' ')
    .trim();
}

/**
 * Compare two arrays of normalized lines for structural similarity.
 * Returns ratio of matching lines (0..1).
 */
function structuralSimilarity(blockA, blockB) {
  if (blockA.length === 0 || blockB.length === 0) return 0;
  const len = Math.min(blockA.length, blockB.length);
  let matches = 0;
  for (let i = 0; i < len; i++) {
    if (blockA[i] === blockB[i]) matches++;
  }
  return matches / Math.max(blockA.length, blockB.length);
}

// ── Detector 1: Repeated useQuery pattern (React/TS) ────────

function repeatedQueryPattern(lines, ext, threshold, severity) {
  if (!['.tsx', '.ts', '.jsx', '.js'].includes(ext)) return [];

  const blocks = [];
  let current = null;
  let depth = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!current && /use(Query|Mutation|InfiniteQuery)\\s*[({]/.test(line)) {
      current = { start: i, lines: [], raw: [] };
      depth = 0;
    }
    if (current) {
      current.lines.push(normalize(line));
      current.raw.push(line);
      depth += (line.match(/[({]/g) || []).length;
      depth -= (line.match(/[)}]/g) || []).length;
      if (depth <= 0 && current.lines.length > 1) {
        blocks.push(current);
        current = null;
      }
      // Safety: don't collect more than 20 lines per block
      if (current && current.lines.length > 20) {
        blocks.push(current);
        current = null;
      }
    }
  }

  if (blocks.length < threshold) return [];

  // Check structural similarity between blocks
  let similarCount = 0;
  for (let i = 1; i < blocks.length; i++) {
    if (structuralSimilarity(blocks[0].lines, blocks[i].lines) >= 0.7) {
      similarCount++;
    }
  }

  if (similarCount + 1 >= threshold) {
    return [{
      severity,
      text: (similarCount + 1) + ' useQuery/useMutation calls with similar structure (lines ' +
        blocks.map(b => b.start + 1).join(', ') + ')',
      suggestion: 'Extract reusable hook in features/*/hooks/ that parameterizes queryKey and queryFn',
      identifier: 'repeated-useQuery',
    }];
  }
  return [];
}

// ── Detector 2: Repeated className strings (JSX) ────────────

function repeatedClassName(lines, ext, threshold, severity) {
  if (!['.tsx', '.jsx'].includes(ext)) return [];

  const classNames = new Map();
  for (let i = 0; i < lines.length; i++) {
    const matches = lines[i].match(/className=["'\`]([^"'\`]{40,})["'\`]/g);
    if (matches) {
      for (const m of matches) {
        const val = m.replace(/className=["'\`]/, '').replace(/["'\`]$/, '').trim();
        if (!classNames.has(val)) classNames.set(val, []);
        classNames.get(val).push(i + 1);
      }
    }
  }

  const messages = [];
  for (const [cls, lineNums] of classNames.entries()) {
    if (lineNums.length >= threshold) {
      const preview = cls.length > 60 ? cls.substring(0, 57) + '...' : cls;
      messages.push({
        severity,
        text: 'className "' + preview + '" repeated ' + lineNums.length + ' times (lines ' +
          lineNums.slice(0, 5).join(', ') + (lineNums.length > 5 ? '...' : '') + ')',
        suggestion: 'Extract to CSS constant, Tailwind class with @apply, or reusable component',
        identifier: 'repeated-className:' + cls.substring(0, 30),
      });
    }
  }
  return messages;
}

// ── Detector 3: Repeated HTTP call wrappers ──────────────────

function repeatedHttpCalls(lines, ext, threshold, severity) {
  if (!['.ts', '.tsx', '.js', '.jsx'].includes(ext)) return [];

  const blocks = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (/await\\s+\\w+\\.(get|post|put|delete|patch)\\s*[<(]/.test(line)) {
      // Collect this line + up to 3 following lines as a block
      const block = [];
      for (let j = i; j < Math.min(i + 4, lines.length); j++) {
        block.push(normalize(lines[j]));
      }
      blocks.push({ start: i, lines: block });
    }
  }

  if (blocks.length < threshold) return [];

  // Group by normalized structure
  const groups = new Map();
  for (const block of blocks) {
    const key = block.lines.join('|');
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(block.start + 1);
  }

  const messages = [];
  for (const [, lineNums] of groups.entries()) {
    if (lineNums.length >= threshold) {
      messages.push({
        severity,
        text: lineNums.length + ' HTTP calls with identical structure (lines ' +
          lineNums.slice(0, 5).join(', ') + ')',
        suggestion: 'Centralize in shared/http/ with generic factory or wrapper function',
        identifier: 'repeated-http:' + lineNums[0],
      });
    }
  }
  return messages;
}

// ── Detector 4: Repeated form fields (JSX) ──────────────────

function repeatedFormFields(lines, ext, threshold, severity) {
  if (!['.tsx', '.jsx'].includes(ext)) return [];

  const blocks = [];
  let current = null;
  let depth = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!current && /<(FormField|FormItem|select|Select|input|Input|TextField)\\b/.test(line)) {
      current = { start: i, lines: [], tag: RegExp.$1 };
      depth = 0;
    }
    if (current) {
      current.lines.push(normalize(line));
      // Track JSX depth by counting < and </ roughly
      if (/<[A-Z]/.test(line)) depth++;
      if (/<\\//.test(line)) depth--;
      if ((depth <= 0 && current.lines.length > 1) || /\\/>/.test(line)) {
        blocks.push(current);
        current = null;
      }
      if (current && current.lines.length > 15) {
        blocks.push(current);
        current = null;
      }
    }
  }

  if (blocks.length < threshold) return [];

  // Check if blocks are structurally similar
  let similarCount = 0;
  for (let i = 1; i < blocks.length; i++) {
    if (structuralSimilarity(blocks[0].lines, blocks[i].lines) >= 0.7) {
      similarCount++;
    }
  }

  if (similarCount + 1 >= threshold) {
    return [{
      severity,
      text: (similarCount + 1) + ' form fields with similar structure (lines ' +
        blocks.map(b => b.start + 1).slice(0, 6).join(', ') + ')',
      suggestion: 'Extract reusable field component that receives config as props',
      identifier: 'repeated-form-fields',
    }];
  }
  return [];
}

// ── Detector 5: Repeated .NET endpoints ──────────────────────

function repeatedEndpoints(lines, ext, threshold, severity) {
  if (ext !== '.cs') return [];

  const blocks = [];
  let current = null;
  let braceDepth = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    // Detect Minimal API endpoints or Controller action attributes
    const isEndpoint =
      /app\\.Map(Get|Post|Put|Delete|Patch)\\s*[<(]/.test(line) ||
      /\\[(Http(Get|Post|Put|Delete|Patch)|Route)/.test(line);

    if (!current && isEndpoint) {
      current = { start: i, lines: [] };
      braceDepth = 0;
    }
    if (current) {
      current.lines.push(normalize(line));
      braceDepth += (line.match(/{/g) || []).length;
      braceDepth -= (line.match(/}/g) || []).length;
      if (braceDepth <= 0 && current.lines.length > 2) {
        blocks.push(current);
        current = null;
      }
      if (current && current.lines.length > 30) {
        blocks.push(current);
        current = null;
      }
    }
  }

  if (blocks.length < threshold) return [];

  // Group similar endpoints
  let similarCount = 0;
  for (let i = 1; i < blocks.length; i++) {
    if (structuralSimilarity(blocks[0].lines, blocks[i].lines) >= 0.6) {
      similarCount++;
    }
  }

  if (similarCount + 1 >= threshold) {
    return [{
      severity,
      text: (similarCount + 1) + ' endpoints with similar structure (lines ' +
        blocks.map(b => b.start + 1).slice(0, 5).join(', ') + ')',
      suggestion: 'Consider generic endpoint factory, MediatR, or shared base method',
      identifier: 'repeated-endpoints',
    }];
  }
  return [];
}

// ── Detector 6: Repeated switch/case branches ────────────────

function repeatedSwitchBranches(lines, ext, threshold, severity) {
  if (!['.ts', '.tsx', '.js', '.jsx', '.cs'].includes(ext)) return [];

  // Find switch statements and collect case blocks
  let inSwitch = false;
  let switchStart = -1;
  let braceDepth = 0;
  const switches = [];
  let currentCases = [];
  let currentCase = null;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (!inSwitch && /\\bswitch\\s*\\(/.test(line)) {
      inSwitch = true;
      switchStart = i;
      braceDepth = 0;
      currentCases = [];
      currentCase = null;
    }

    if (inSwitch) {
      braceDepth += (line.match(/{/g) || []).length;
      braceDepth -= (line.match(/}/g) || []).length;

      if (/^\\s*(case\\b|default\\s*:)/.test(line)) {
        if (currentCase && currentCase.lines.length > 0) {
          currentCases.push(currentCase);
        }
        currentCase = { start: i, lines: [] };
      } else if (currentCase) {
        currentCase.lines.push(normalize(line));
      }

      if (braceDepth <= 0 && inSwitch) {
        if (currentCase && currentCase.lines.length > 0) {
          currentCases.push(currentCase);
        }
        if (currentCases.length >= threshold) {
          switches.push({ start: switchStart, cases: currentCases });
        }
        inSwitch = false;
        currentCases = [];
        currentCase = null;
      }
    }
  }

  const messages = [];
  for (const sw of switches) {
    // Check if case bodies are structurally similar
    let similarCount = 0;
    const first = sw.cases[0];
    for (let i = 1; i < sw.cases.length; i++) {
      if (first.lines.length > 0 && structuralSimilarity(first.lines, sw.cases[i].lines) >= 0.7) {
        similarCount++;
      }
    }

    if (similarCount + 1 >= threshold) {
      messages.push({
        severity,
        text: 'switch with ' + (similarCount + 1) + ' structurally similar branches (line ' +
          (sw.start + 1) + ')',
        suggestion: 'Consider dictionary/map lookup or strategy pattern to eliminate repeated branches',
        identifier: 'repeated-switch:' + (sw.start + 1),
      });
    }
  }
  return messages;
}

// ── Detector 7: Repeated try/catch blocks ────────────────────

function repeatedTryCatch(lines, ext, threshold, severity) {
  if (!['.ts', '.tsx', '.js', '.jsx', '.cs'].includes(ext)) return [];

  const catchBlocks = [];
  let inCatch = false;
  let braceDepth = 0;
  let current = null;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (!inCatch && /\\bcatch\\s*\\(/.test(line)) {
      inCatch = true;
      current = { start: i, lines: [] };
      braceDepth = 0;
    }

    if (inCatch) {
      current.lines.push(normalize(line));
      braceDepth += (line.match(/{/g) || []).length;
      braceDepth -= (line.match(/}/g) || []).length;

      if (braceDepth <= 0 && current.lines.length > 1) {
        catchBlocks.push(current);
        inCatch = false;
        current = null;
      }
      if (current && current.lines.length > 15) {
        catchBlocks.push(current);
        inCatch = false;
        current = null;
      }
    }
  }

  if (catchBlocks.length < threshold) return [];

  // Group similar catch blocks
  const groups = [];
  const used = new Set();
  for (let i = 0; i < catchBlocks.length; i++) {
    if (used.has(i)) continue;
    const group = [catchBlocks[i]];
    for (let j = i + 1; j < catchBlocks.length; j++) {
      if (used.has(j)) continue;
      if (structuralSimilarity(catchBlocks[i].lines, catchBlocks[j].lines) >= 0.8) {
        group.push(catchBlocks[j]);
        used.add(j);
      }
    }
    if (group.length >= threshold) {
      groups.push(group);
    }
    used.add(i);
  }

  const messages = [];
  for (const group of groups) {
    messages.push({
      severity,
      text: group.length + ' catch blocks with similar structure (lines ' +
        group.map(b => b.start + 1).join(', ') + ')',
      suggestion: 'Extract reusable error handler or error middleware',
      identifier: 'repeated-catch:' + group[0].start,
    });
  }
  return messages;
}

// ── Phase 2: Cross-file fingerprint matching ─────────────────

function isTrivialLine(trimmed) {
  if (!trimmed) return true;
  if (trimmed.length <= 3) return true;
  if (/^(import|export)\\s/.test(trimmed) && !trimmed.includes('function')) return true;
  if (/^\\/\\//.test(trimmed)) return true;
  if (/^\\/\\*/.test(trimmed) || /^\\*/.test(trimmed)) return true;
  return false;
}

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const chr = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash.toString(36);
}

function checkCrossFilePatterns(lines, ext, ctx, severity) {
  const fs = require('fs');
  const path = require('path');

  // Load pattern index — graceful fallback if not available
  const indexPath = path.join(ctx.claudeDir, 'pattern-index.json');
  let index;
  try { index = JSON.parse(fs.readFileSync(indexPath, 'utf-8')); }
  catch { return []; }

  if (!index || !index.fingerprints) return [];

  const WINDOW = index.windowSize || 4;
  const messages = [];
  const reported = new Set();

  // Filter to meaningful lines
  const meaningful = [];
  for (let i = 0; i < lines.length; i++) {
    const trimmed = lines[i].trim();
    if (isTrivialLine(trimmed)) continue;
    const norm = normalize(lines[i]);
    if (norm.length < 5) continue;
    meaningful.push({ normalized: norm, originalLine: i + 1 });
  }

  // Sliding window over meaningful lines
  for (let i = 0; i <= meaningful.length - WINDOW; i++) {
    const windowLines = meaningful.slice(i, i + WINDOW).map(m => m.normalized);
    const hash = simpleHash(windowLines.join('|'));

    if (index.fingerprints[hash]) {
      const entry = index.fingerprints[hash];
      // Filter out matches in the same file
      const otherFiles = entry.locations.filter(
        loc => loc.file !== ctx.relativePath
      );
      if (otherFiles.length === 0) continue;

      // Only report once per matching file (avoid flooding)
      const fileKey = otherFiles[0].file;
      if (reported.has(fileKey)) continue;
      reported.add(fileKey);

      const firstMatch = otherFiles[0];
      messages.push({
        severity,
        text: 'Code block similar to ' + firstMatch.file + ':' + firstMatch.line +
          (otherFiles.length > 1 ? ' (and ' + (otherFiles.length - 1) + ' more locations)' : ''),
        suggestion: 'Consider extracting to a shared function or reusing the existing one',
        identifier: 'cross-file:' + hash.substring(0, 8),
      });
    }
  }

  // Cap messages to avoid noise
  return messages.slice(0, 5);
}
`;
}
