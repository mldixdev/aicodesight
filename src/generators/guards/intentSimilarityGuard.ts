/**
 * Generates intent-similarity.js guard — warns when creating a file
 * that looks similar to an existing entry in capability-index.json.
 *
 * Comparison is simple: substring match on name + exact match on
 * domain/action/entity (OR logic). No synonyms, no normalization.
 * The AI decides similarity, the guard only provides visibility.
 */
export function generateIntentSimilarityGuard(): string {
  return `/**
 * intent-similarity.js — Guard: Similar intent feedback
 * Generated by AICodeSight. Shows existing similar entries when creating files.
 *
 * Only warns, NEVER blocks. Information for the AI to decide.
 */
const fs = require('fs');
const path = require('path');

module.exports = {
  name: 'intent-similarity',

  check(ctx) {
    const config = ctx.config.guards['intent-similarity'] || {};
    if (config.severity === 'off') return { passed: true, messages: [] };

    // Only check Write operations (new file creation)
    if (ctx.tool !== 'Write' && ctx.tool !== 'write') return { passed: true, messages: [] };

    const filePath = ctx.filePath || '';
    if (!filePath) return { passed: true, messages: [] };

    // Load capability index
    const indexPath = path.join(ctx.projectRoot, '.claude', 'capability-index.json');
    let index;
    try { index = JSON.parse(fs.readFileSync(indexPath, 'utf-8')); }
    catch { return { passed: true, messages: [] }; }

    if (!index.entries || index.entries.length === 0) return { passed: true, messages: [] };

    const messages = [];
    const relPath = path.relative(ctx.projectRoot, filePath).replace(/\\\\/g, '/');
    const fileName = path.basename(relPath, path.extname(relPath)).toLowerCase();

    // Extract words from filename for comparison
    const fileWords = splitWords(fileName);

    // Find similar entries
    const similar = [];
    for (const entry of index.entries) {
      if (entry.file.replace(/\\\\/g, '/') === relPath) continue; // Skip self

      let score = 0;
      const reasons = [];

      // 1. Name substring match
      const entryName = entry.name.toLowerCase();
      if (fileName.includes(entryName) || entryName.includes(fileName)) {
        score += 3;
        reasons.push('similar name');
      }

      // 2. Word overlap (at least 2 shared words of 4+ chars)
      const entryWords = splitWords(entryName);
      const sharedWords = fileWords.filter(w => w.length >= 4 && entryWords.includes(w));
      if (sharedWords.length >= 2) {
        score += 2;
        reasons.push('shared words: ' + sharedWords.join(', '));
      }

      // 3. Domain/action/entity match (from declared/enriched entries)
      if (entry.domain || entry.action || entry.entity) {
        // Check if any of the file words match domain/action/entity
        for (const word of fileWords) {
          if (word.length < 3) continue;
          if (entry.domain && entry.domain.toLowerCase().includes(word)) {
            score += 1;
            reasons.push('domain: ' + entry.domain);
            break;
          }
          if (entry.action && entry.action.toLowerCase().includes(word)) {
            score += 1;
            reasons.push('action: ' + entry.action);
            break;
          }
          if (entry.entity && entry.entity.toLowerCase().includes(word)) {
            score += 1;
            reasons.push('entity: ' + entry.entity);
            break;
          }
        }
      }

      if (score >= 2) {
        similar.push({
          name: entry.name,
          file: entry.file,
          description: entry.description,
          reasons,
          score,
        });
      }
    }

    if (similar.length === 0) return { passed: true, messages: [] };

    // Sort by score descending, take top 5
    similar.sort((a, b) => b.score - a.score);
    const top = similar.slice(0, 5);

    const lines = top.map(s => {
      const desc = s.description ? ' — ' + s.description : '';
      return '  - ' + s.file + ' (' + s.reasons.join(', ') + ')' + desc;
    });

    messages.push({
      severity: config.severity || 'info',
      text: 'Existing similar files:\\n' + lines.join('\\n') +
        '\\nCheck if you can reuse or extend before creating.',
    });

    // Never block — always pass
    return { passed: true, messages };
  },
};

function splitWords(name) {
  return name
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2')
    .split(/[\\s_\\-./]+/)
    .map(w => w.toLowerCase())
    .filter(w => w.length > 2);
}
`;
}
