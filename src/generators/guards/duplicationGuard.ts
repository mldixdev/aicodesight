/**
 * Generates duplication.js guard — detects duplicate exports
 * using exact + fuzzy matching with actionable suggestions.
 */
export function generateDuplicationGuard(): string {
  return `/**
 * duplication.js — Guard: Duplicate export detection
 * Generated by AICodeSight. Exact + fuzzy matching with actionable suggestions.
 */
module.exports = {
  name: 'duplication',

  check(ctx) {
    if (!ctx.inventory || !ctx.fileExports.length) return { passed: true, messages: [] };

    const config = ctx.config.guards.duplication || {};
    const fuzzyThreshold = config.fuzzyThreshold || 0.6;
    const whitelist = new Set(ctx.config.whitelist || []);

    // Build registry: exportName → [{ file, line, type }]
    // Skip barrel files (index.ts/index.js) — they re-export, not duplicate
    const BARREL_NAMES = new Set(['index']);
    const registry = new Map();
    for (const file of ctx.inventory.files) {
      if (file.path === ctx.relativePath) continue;
      const ext = file.path.match(/\\.([^.]+)$/);
      const base = file.path.replace(/\\\\/g, '/').split('/').pop().replace(/\\.[^.]+$/, '').toLowerCase();
      if (BARREL_NAMES.has(base)) continue;
      for (const exp of file.exports) {
        if (exp.name === 'default') continue;
        if (!registry.has(exp.name)) registry.set(exp.name, []);
        registry.get(exp.name).push({ file: file.path, line: exp.line, type: exp.type, signature: exp.signature });
      }
    }

    // Determine if current file is a different stack than a match
    const currentExt = ctx.relativePath.match(/\\.([^.]+)$/);
    const currentIsCSharp = currentExt && currentExt[1] === 'cs';
    function isCrossStack(matchFile) {
      const matchExt = matchFile.match(/\\.([^.]+)$/);
      const matchIsCSharp = matchExt && matchExt[1] === 'cs';
      return currentIsCSharp !== matchIsCSharp;
    }

    const messages = [];

    for (const exp of ctx.fileExports) {
      if (exp.name === 'default' || whitelist.has(exp.name)) continue;

      // 1. Exact match
      if (registry.has(exp.name)) {
        const locations = registry.get(exp.name);
        // Filter out cross-stack matches (backend .cs ↔ frontend .ts are intentional mirrors)
        const sameStackLocs = locations.filter(l => !isCrossStack(l.file));
        if (sameStackLocs.length > 0) {
          // Check if signatures differ → polymorphic, not duplicate
          const expSig = exp.signature || null;
          const matchSig = sameStackLocs[0].signature || null;
          const sigsDiffer = expSig && matchSig && expSig !== matchSig;

          if (!sigsDiffer) {
            const first = sameStackLocs[0];
            const importPath = computeImportPath(ctx.relativePath, first.file);
            const otherFiles = sameStackLocs.map(l => l.file + ':' + l.line).join(', ');

            messages.push({
              severity: 'block',
              identifier: 'exact:' + exp.name,
              text: 'Export "' + exp.name + '" already exists in: ' + otherFiles,
              suggestion: 'import { ' + exp.name + ' } from "' + importPath + '"',
            });
          }
        }
        continue;
      }

      // 2. Fuzzy match (bigram similarity)
      const fuzzyMatches = [];
      for (const [name, locations] of registry.entries()) {
        if (name.length < 4) continue; // Skip short names
        const similarity = bigramSimilarity(exp.name.toLowerCase(), name.toLowerCase());
        if (similarity >= fuzzyThreshold && similarity < 1.0) {
          fuzzyMatches.push({ name, similarity, locations });
        }
      }

      if (fuzzyMatches.length > 0) {
        fuzzyMatches.sort((a, b) => b.similarity - a.similarity);
        const best = fuzzyMatches[0];
        const pct = Math.round(best.similarity * 100);
        const first = best.locations[0];
        const importPath = computeImportPath(ctx.relativePath, first.file);

        messages.push({
          severity: 'info',
          identifier: 'fuzzy:' + exp.name + ':' + best.name,
          text: 'Export "' + exp.name + '" is similar to "' + best.name + '" (' + pct + '% match) in ' + first.file + ':' + first.line,
          suggestion: 'If it is the same: import { ' + best.name + ' } from "' + importPath + '"',
        });
      }
    }

    return { passed: messages.length === 0, messages };
  },
};

/**
 * Bigram (Dice) similarity: 2 * |intersection| / (|a| + |b|)
 * Fast, no dependencies, good for identifier comparison.
 */
function bigramSimilarity(a, b) {
  if (a === b) return 1.0;
  if (a.length < 2 || b.length < 2) return 0;

  const bigramsA = new Map();
  for (let i = 0; i < a.length - 1; i++) {
    const bg = a.substring(i, i + 2);
    bigramsA.set(bg, (bigramsA.get(bg) || 0) + 1);
  }

  let intersection = 0;
  for (let i = 0; i < b.length - 1; i++) {
    const bg = b.substring(i, i + 2);
    const count = bigramsA.get(bg);
    if (count > 0) {
      bigramsA.set(bg, count - 1);
      intersection++;
    }
  }

  return (2.0 * intersection) / (a.length - 1 + b.length - 1);
}

/**
 * Compute relative import path from source file to target file.
 * E.g., from "src/features/auth.ts" to "src/utils/format.ts" → "../utils/format"
 */
function computeImportPath(fromFile, toFile) {
  const path = require('path');
  const fromDir = path.dirname(fromFile);
  let rel = path.relative(fromDir, toFile).replace(/\\\\/g, '/');
  // Remove extension
  rel = rel.replace(/\\.(ts|tsx|js|jsx|cs)$/, '');
  if (!rel.startsWith('.')) rel = './' + rel;
  return rel;
}
`;
}
