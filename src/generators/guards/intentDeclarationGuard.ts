/**
 * @intent Generate intent-declaration.js guard — enforces @intent headers on new source files with behavioral exports
 * @domain generators/guards
 */
export function generateIntentDeclarationGuard(): string {
  return `/**
 * intent-declaration.js — Guard: Mandatory intent declaration
 * Generated by AICodeSight.
 *
 * Requires that NEW files with behavioral exports (function, class)
 * include an @intent in a header comment.
 *
 * Configuration in guard-config.json:
 *   "intent-declaration": {
 *     "severity": "warn"
 *   }
 */
module.exports = {
  name: 'intent-declaration',

  check(ctx) {
    const messages = [];

    // Only enforce on Write (new file creation), not Edit
    if (ctx.toolName !== 'write') return { passed: true, messages: [] };

    const isTs = ['.ts', '.tsx', '.js', '.jsx'].includes(ctx.ext);
    const isCs = ctx.ext === '.cs';
    if (!isTs && !isCs) return { passed: true, messages: [] };

    // Only for NEW files (doesn't exist on disk yet)
    const fs = require('fs');
    if (fs.existsSync(ctx.filePath)) return { passed: true, messages: [] };

    // Skip excluded patterns
    const path = require('path');
    const baseName = path.basename(ctx.filePath, ctx.ext);

    // Generated files in .claude/
    if (ctx.relativePath.startsWith('.claude/')) return { passed: true, messages: [] };

    // TS/JS exclusions
    if (isTs) {
      if (baseName === 'index' || baseName === 'barrel') return { passed: true, messages: [] };
      if (baseName.endsWith('.test') || baseName.endsWith('.spec')) return { passed: true, messages: [] };
      if (baseName.endsWith('.types') || baseName.endsWith('.d')) return { passed: true, messages: [] };
      if (baseName.endsWith('.config')) return { passed: true, messages: [] };
    }

    // C# exclusions
    if (isCs) {
      if (baseName === 'Program' || baseName === 'Startup') return { passed: true, messages: [] };
      if (baseName.endsWith('.Designer') || baseName.endsWith('.g') || baseName.endsWith('.AssemblyInfo')) return { passed: true, messages: [] };
      if (ctx.relativePath.includes('Migrations/') || ctx.relativePath.includes('Migrations\\\\')) return { passed: true, messages: [] };
    }

    // Check for behavioral exports (function or class, not just types/interfaces)
    const hasBehavioralExports = ctx.fileExports.some(function(e) {
      return e.type === 'function' || e.type === 'class';
    });
    if (!hasBehavioralExports) return { passed: true, messages: [] };

    // Check for @intent tag in proposed content
    const hasIntent = ctx.content.includes('@intent ');

    if (!hasIntent) {
      const suggestion = isCs
        ? 'Add /// <summary>\\n/// @intent Module description\\n/// </summary> at the top of the file'
        : 'Add /** @intent Module description */ at the top of the file';
      messages.push({
        severity: 'block',
        identifier: 'intent-declaration:missing:' + ctx.relativePath,
        text: 'New file with behavioral exports requires @intent header',
        suggestion: suggestion,
      });
    }

    return { passed: messages.length === 0, messages };
  },
};
`;
}
