/**
 * Generates coherence.js guard — detects exports that don't belong
 * to the file's apparent domain/responsibility.
 */
export function generateCoherenceGuard(): string {
  return `/**
 * coherence.js — Guard: Export-domain coherence
 * Generated by AICodeSight.
 *
 * Tokenizes the file name and each export, compares overlap.
 * If an export shares no tokens with the file, it flags it.
 * E.g.: formatDate in UserService.ts → incoherent.
 */
module.exports = {
  name: 'coherence',

  check(ctx) {
    const path = require('path');
    const messages = [];

    // Extract domain tokens from file path
    const baseName = path.basename(ctx.relativePath, path.extname(ctx.relativePath));
    // Skip generic files — they're expected to have diverse exports
    const generics = ['utils','helpers','common','shared','misc','tools','lib','functions','index'];
    if (generics.includes(baseName.toLowerCase())) return { passed: true, messages: [] };

    const fileTokens = new Set(tokenize(baseName));
    // Also add parent directory name as context
    const parentDir = path.basename(path.dirname(ctx.relativePath));
    if (parentDir && parentDir !== '.') {
      for (const t of tokenize(parentDir)) fileTokens.add(t);
    }

    if (fileTokens.size === 0) return { passed: true, messages: [] };

    for (const exp of ctx.fileExports) {
      if (exp.name === 'default' || exp.name.length < 4) continue;
      // Types/interfaces often have generic names — be lenient
      if (exp.type === 'type' || exp.type === 'interface') continue;

      const exportTokens = tokenize(exp.name);
      const overlap = exportTokens.filter(t => fileTokens.has(t));

      if (overlap.length === 0 && exportTokens.length >= 2) {
        messages.push({
          severity: 'info',
          identifier: 'coherence:' + exp.name + ':' + baseName,
          text: 'Export "' + exp.name + '" does not seem to belong in "' + baseName + '"',
          suggestion: 'Move to a file whose name reflects this responsibility',
        });
      }
    }

    return { passed: messages.length === 0, messages };
  },
};

/**
 * Split camelCase/PascalCase identifiers into lowercase tokens.
 * "formatPhoneNumber" → ["format", "phone", "number"]
 * "UserService" → ["user", "service"]
 */
function tokenize(name) {
  return name
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2')
    .replace(/[-_.]/g, ' ')
    .toLowerCase()
    .split(/\\s+/)
    .filter(t => t.length >= 3);
}
`;
}
