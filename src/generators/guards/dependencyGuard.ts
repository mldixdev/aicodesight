/**
 * Generates dependency.js guard — detects circular imports
 * and architectural zone violations.
 *
 * Language-aware:
 * - TypeScript/JS: resolves relative import/require paths
 * - C#: extracts using statements, builds namespace→file index from inventory,
 *   resolves cross-project references for zone violation detection
 */
export function generateDependencyGuard(): string {
  return `/**
 * dependency.js — Guard: Circular dependencies and architectural zones
 * Generated by AICodeSight.
 *
 * TypeScript/JS: analyzes relative import/require paths
 * C#: analyzes using statements, builds namespace index from inventory
 *
 * Checks:
 * 1. Circular dependencies (1-hop)
 * 2. Architectural zone violations (guard-config.json zones)
 */
module.exports = {
  name: 'dependency',

  check(ctx) {
    const path = require('path');
    const fs = require('fs');
    const messages = [];
    const isCSharp = ctx.ext === '.cs';

    if (isCSharp) {
      checkCSharpDependencies(ctx, messages, path, fs);
    } else {
      checkJsDependencies(ctx, messages, path, fs);
    }

    return { passed: messages.length === 0, messages };
  },
};

// ═══════════════════════════════════════════════════════════════
//  C# dependency analysis
// ═══════════════════════════════════════════════════════════════

function checkCSharpDependencies(ctx, messages, path, fs) {
  // Extract using statements (skip System, Microsoft, and other framework namespaces)
  const usings = extractCSharpUsings(ctx.content);
  if (usings.length === 0) return;

  // Build namespace → file paths index from inventory
  const nsIndex = buildNamespaceIndex(ctx.inventory, path);

  // Extract current file's namespace
  const myNamespace = extractCSharpNamespace(ctx.content);

  // 1. Zone violations via namespace resolution
  const zones = ctx.config.zones || {};
  const zoneEntries = Object.entries(zones);

  if (zoneEntries.length > 0) {
    const myZone = findZone(ctx.relativePath, zoneEntries);

    for (const ns of usings) {
      // Find files that belong to this namespace (exact or parent match)
      const targetFiles = resolveNamespaceToFiles(ns, nsIndex);
      if (targetFiles.length === 0) continue;

      // All files in the same namespace typically belong to the same zone
      const targetZone = findZone(targetFiles[0], zoneEntries);
      if (myZone && targetZone && myZone !== targetZone) {
        if (targetZone === 'shared' || targetZone === 'common') continue;

        messages.push({
          severity: 'warn',
          identifier: 'zone:' + myZone + ':' + targetZone,
          text: 'Zone "' + myZone + '" imports namespace from zone "' + targetZone + '" (using ' + ns + ')',
          suggestion: 'Move shared logic to "shared" zone or use abstraction (interface in Core)',
        });
      }
    }
  }

  // 2. Circular dependency detection via namespaces
  if (myNamespace && ctx.inventory) {
    for (const ns of usings) {
      const targetFiles = resolveNamespaceToFiles(ns, nsIndex);
      for (const targetPath of targetFiles) {
        try {
          const targetContent = fs.readFileSync(path.join(ctx.projectRoot, targetPath), 'utf-8');
          const targetUsings = extractCSharpUsings(targetContent);

          // Check if target references back to our namespace
          if (targetUsings.some(u => myNamespace === u || myNamespace.startsWith(u + '.'))) {
            messages.push({
              severity: 'warn',
              identifier: 'circular:' + ctx.relativePath + ':' + targetPath,
              text: 'Circular dependency: ' + ctx.relativePath + ' ↔ ' + targetPath + ' (via namespaces)',
              suggestion: 'Extract interfaces to a shared project or invert the dependency',
            });
            break;
          }
        } catch { /* skip unreadable files */ }
      }
    }
  }
}

/**
 * Extracts non-framework using statements from C# content.
 * Skips: System.*, Microsoft.*, and common third-party root namespaces.
 */
function extractCSharpUsings(content) {
  const usings = [];
  const frameworkPrefixes = [
    'System', 'Microsoft', 'Newtonsoft', 'AutoMapper', 'MediatR',
    'FluentValidation', 'Serilog', 'NLog', 'Swashbuckle', 'Xunit',
    'NUnit', 'Moq', 'Bogus', 'Dapper', 'StackExchange', 'Polly',
    'Humanizer', 'Mapster', 'Hangfire', 'Quartz',
  ];
  const lines = content.split('\\n');

  for (const line of lines) {
    // Match: using Namespace.Sub; (skip 'using static' and 'using alias = ...')
    const match = line.match(/^\\s*using\\s+(?!static\\s)(?!\\w+\\s*=)(\\S+?)\\s*;/);
    if (!match) continue;

    const ns = match[1];
    const root = ns.split('.')[0];
    if (frameworkPrefixes.includes(root)) continue;

    usings.push(ns);
  }

  return usings;
}

/**
 * Extracts the namespace declaration from a C# file.
 * Supports both block-scoped and file-scoped (C# 10+) namespaces.
 */
function extractCSharpNamespace(content) {
  const lines = content.split('\\n');
  for (const line of lines) {
    // File-scoped namespace (C# 10+): namespace X.Y.Z;
    const fileScoped = line.match(/^\\s*namespace\\s+(\\S+?)\\s*;/);
    if (fileScoped) return fileScoped[1];

    // Block-scoped namespace: namespace X.Y.Z {
    const blockScoped = line.match(/^\\s*namespace\\s+(\\S+?)\\s*\\{?\\s*$/);
    if (blockScoped) return blockScoped[1];
  }
  return null;
}

/**
 * Builds namespace → [file paths] index from inventory.
 * Infers namespaces from file paths using .NET conventions:
 * - Finds the "root namespace" segment (contains a dot, like "PortalIndicadores.Core")
 * - Appends subdirectory names as namespace segments
 */
function buildNamespaceIndex(inventory, path) {
  const index = {};
  if (!inventory || !inventory.files) return index;

  for (const file of inventory.files) {
    if (!file.path.endsWith('.cs')) continue;
    const ns = inferNamespaceFromPath(file.path, path);
    if (!ns) continue;

    if (!index[ns]) index[ns] = [];
    index[ns].push(file.path);
  }

  return index;
}

/**
 * Infers the probable namespace from a C# file path.
 *
 * Example: Backend/PortalIndicadores.Core/Services/MedicionService.cs
 *   → segments: ['Backend', 'PortalIndicadores.Core', 'Services']
 *   → root namespace segment: 'PortalIndicadores.Core' (contains dot)
 *   → result: 'PortalIndicadores.Core.Services'
 *
 * If no dotted segment, uses all directory segments joined with dots.
 */
function inferNamespaceFromPath(filePath, path) {
  const normalized = filePath.replace(/\\\\/g, '/');
  const parts = normalized.split('/');
  parts.pop(); // remove filename

  if (parts.length === 0) return null;

  // Find the root namespace segment (first segment containing a dot)
  let rootIdx = -1;
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].includes('.')) { rootIdx = i; break; }
  }

  if (rootIdx >= 0) {
    // Root namespace + subdirectories
    const nsSegments = parts.slice(rootIdx);
    return nsSegments.join('.');
  }

  // No dotted segment — use all segments (common in single-project solutions)
  return parts.join('.');
}

/**
 * Resolves a using namespace to matching file paths.
 * Matches exact namespace and parent namespace (files "inside" the using target).
 */
function resolveNamespaceToFiles(targetNs, nsIndex) {
  const files = [];

  for (const [ns, paths] of Object.entries(nsIndex)) {
    // Exact match: using X.Y.Z → files in namespace X.Y.Z
    if (ns === targetNs) {
      files.push(...paths);
      continue;
    }
    // Parent match: using X.Y → files in namespace X.Y.Sub
    if (ns.startsWith(targetNs + '.')) {
      files.push(...paths);
    }
  }

  return files;
}

// ═══════════════════════════════════════════════════════════════
//  TypeScript / JavaScript dependency analysis
// ═══════════════════════════════════════════════════════════════

function checkJsDependencies(ctx, messages, path, fs) {
  const imports = extractJsImports(ctx.content);
  if (imports.length === 0) return;

  // 1. Circular dependency detection (1-hop)
  for (const imp of imports) {
    const targetPath = resolveImportPath(imp, ctx.relativePath, ctx.projectRoot, path, fs);
    if (!targetPath) continue;

    try {
      const targetContent = fs.readFileSync(path.join(ctx.projectRoot, targetPath), 'utf-8');
      const targetImports = extractJsImports(targetContent);
      const normalized = ctx.relativePath.replace(/\\.(ts|tsx|js|jsx)$/, '');

      for (const ti of targetImports) {
        const resolvedBack = resolveImportPath(ti, targetPath, ctx.projectRoot, path, fs);
        if (resolvedBack && resolvedBack.replace(/\\.(ts|tsx|js|jsx)$/, '') === normalized) {
          messages.push({
            severity: 'warn',
            identifier: 'circular:' + ctx.relativePath + ':' + targetPath,
            text: 'Circular dependency: ' + ctx.relativePath + ' ↔ ' + targetPath,
            suggestion: 'Extract shared logic to a third file',
          });
          break;
        }
      }
    } catch { /* target file not readable, skip */ }
  }

  // 2. Zone violations
  const zones = ctx.config.zones || {};
  const zoneEntries = Object.entries(zones);
  if (zoneEntries.length > 0) {
    const myZone = findZone(ctx.relativePath, zoneEntries);

    for (const imp of imports) {
      const targetPath = resolveImportPath(imp, ctx.relativePath, ctx.projectRoot, path, fs);
      if (!targetPath) continue;

      const targetZone = findZone(targetPath, zoneEntries);
      if (myZone && targetZone && myZone !== targetZone) {
        if (targetZone === 'shared' || targetZone === 'common') continue;

        messages.push({
          severity: 'warn',
          identifier: 'zone:' + myZone + ':' + targetZone,
          text: 'Zone "' + myZone + '" imports from zone "' + targetZone + '"',
          suggestion: 'Move shared logic to "shared" zone or restructure',
        });
      }
    }
  }
}

function extractJsImports(content) {
  const imports = [];
  const lines = content.split('\\n');
  for (const line of lines) {
    const match = line.match(/(?:import|from)\\s+['\"](\\.{1,2}\\/[^'\"]+)['\"]/);
    if (match) imports.push(match[1]);
    const reqMatch = line.match(/require\\s*\\(\\s*['\"](\\.{1,2}\\/[^'\"]+)['\"]\\s*\\)/);
    if (reqMatch) imports.push(reqMatch[1]);
  }
  return imports;
}

function resolveImportPath(importStr, fromFile, projectRoot, path, fs) {
  const dir = path.dirname(fromFile);
  let resolved = path.join(dir, importStr).replace(/\\\\/g, '/');

  const extensions = ['.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.js'];
  for (const ext of extensions) {
    const candidate = resolved + ext;
    try {
      fs.accessSync(path.join(projectRoot, candidate));
      return candidate;
    } catch { /* continue */ }
  }

  try {
    fs.accessSync(path.join(projectRoot, resolved));
    return resolved;
  } catch { return null; }
}

// ═══════════════════════════════════════════════════════════════
//  Shared
// ═══════════════════════════════════════════════════════════════

function findZone(filePath, zoneEntries) {
  const normalized = filePath.replace(/\\\\/g, '/');
  for (const [zone, patterns] of zoneEntries) {
    for (const pattern of patterns) {
      if (normalized.startsWith(pattern) || normalized.includes('/' + pattern)) {
        return zone;
      }
    }
  }
  return null;
}
`;
}
