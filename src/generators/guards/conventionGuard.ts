/**
 * Generates convention.js guard — enforces naming conventions per export type.
 * Language-aware: applies different rule sets for TypeScript/JS vs C#.
 */
export function generateConventionGuard(): string {
  return `/**
 * convention.js — Guard: Naming convention verification
 * Generated by AICodeSight.
 *
 * Rules per language:
 *
 * TypeScript/JavaScript:
 *   - functions/const → camelCase (allows UPPER_CASE for constants)
 *   - class/interface/type/enum → PascalCase
 *   - Interfaces: I prefix discouraged (modern TS style)
 *   - File with 1 class → filename should match
 *
 * C#:
 *   - All public → PascalCase (classes, interfaces, enums)
 *   - Interfaces: I prefix is REQUIRED (IRepository, IService)
 *   - File should match the primary class/interface
 */
module.exports = {
  name: 'convention',

  check(ctx) {
    const messages = [];
    const path = require('path');
    const isCSharp = ctx.ext === '.cs';
    const convConf = ctx.config.guards.convention || {};

    if (isCSharp) {
      checkCSharpConventions(ctx, convConf, messages, path);
    } else {
      checkTypeScriptConventions(ctx, convConf, messages, path);
    }

    return { passed: messages.length === 0, messages };
  },
};

// ═══════════════════════════════════════════════════════════════
//  C# conventions
// ═══════════════════════════════════════════════════════════════

function checkCSharpConventions(ctx, conf, messages, path) {
  for (const exp of ctx.fileExports) {
    // All public C# symbols must be PascalCase
    if (!isPascalCase(exp.name)) {
      messages.push({
        severity: 'info',
        identifier: 'convention:pascal:' + exp.name,
        text: exp.type + ' "' + exp.name + '" should be PascalCase (C# convention)',
        suggestion: 'Rename to: ' + toPascalCase(exp.name),
      });
    }

    // Interfaces MUST have I prefix in C#
    if (exp.type === 'interface' && !/^I[A-Z]/.test(exp.name)) {
      messages.push({
        severity: 'warn',
        identifier: 'convention:iprefix:' + exp.name,
        text: 'Interface "' + exp.name + '" must use I prefix (C# convention)',
        suggestion: 'Rename to: I' + exp.name,
      });
    }
  }

  // Filename must match primary type
  const primaryTypes = ctx.fileExports.filter(e => e.type === 'class' || e.type === 'interface');
  if (primaryTypes.length === 1) {
    const baseName = path.basename(ctx.relativePath, '.cs');
    const typeName = primaryTypes[0].name;
    if (baseName !== typeName) {
      messages.push({
        severity: 'info',
        identifier: 'convention:filename:' + ctx.relativePath,
        text: 'File "' + baseName + '.cs" contains ' + primaryTypes[0].type + ' "' + typeName + '" — names do not match',
        suggestion: 'Rename file to ' + typeName + '.cs',
      });
    }
  }
}

// ═══════════════════════════════════════════════════════════════
//  TypeScript / JavaScript conventions
// ═══════════════════════════════════════════════════════════════

function checkTypeScriptConventions(ctx, conf, messages, path) {
  for (const exp of ctx.fileExports) {
    if (exp.name === 'default') continue;

    // PascalCase types
    if (['class', 'interface', 'type', 'enum'].includes(exp.type)) {
      if (!isPascalCase(exp.name)) {
        messages.push({
          severity: 'info',
          identifier: 'convention:pascal:' + exp.name,
          text: exp.type + ' "' + exp.name + '" should be PascalCase',
          suggestion: 'Rename to: ' + toPascalCase(exp.name),
        });
      }

      // Hungarian notation — only discouraged in TS/JS
      if (exp.type === 'interface' && /^I[A-Z]/.test(exp.name)) {
        messages.push({
          severity: 'info',
          identifier: 'convention:hungarian:' + exp.name,
          text: 'Interface "' + exp.name + '" uses I prefix (Hungarian notation)',
          suggestion: 'Modern TypeScript style: ' + exp.name.substring(1),
        });
      }
    }

    // camelCase functions/const
    if (['function', 'const'].includes(exp.type)) {
      if (isUpperCase(exp.name)) continue;
      if (!isCamelCase(exp.name)) {
        messages.push({
          severity: 'info',
          identifier: 'convention:camel:' + exp.name,
          text: exp.type + ' "' + exp.name + '" should be camelCase',
          suggestion: 'Rename to: ' + toCamelCase(exp.name),
        });
      }
    }
  }

  // Filename: single class → filename should match
  const classes = ctx.fileExports.filter(e => e.type === 'class');
  if (classes.length === 1) {
    const baseName = path.basename(ctx.relativePath, path.extname(ctx.relativePath));
    const className = classes[0].name;
    if (baseName !== className && baseName !== toCamelCase(className)) {
      messages.push({
        severity: 'info',
        identifier: 'convention:filename:' + ctx.relativePath,
        text: 'File "' + baseName + '" exports class "' + className + '" — names do not match',
        suggestion: 'Rename file to ' + className + path.extname(ctx.relativePath),
      });
    }
  }
}

// ═══════════════════════════════════════════════════════════════
//  Helpers
// ═══════════════════════════════════════════════════════════════

function isPascalCase(s) { return /^[A-Z][a-zA-Z0-9]*$/.test(s); }
function isCamelCase(s) { return /^[a-z][a-zA-Z0-9]*$/.test(s); }
function isUpperCase(s) { return /^[A-Z][A-Z0-9_]*$/.test(s); }

function toPascalCase(s) {
  return s.replace(/(?:^|[-_])([a-zA-Z])/g, (_, c) => c.toUpperCase());
}

function toCamelCase(s) {
  const pascal = toPascalCase(s);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}
`;
}
