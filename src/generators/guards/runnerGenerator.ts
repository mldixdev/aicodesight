import { HooksMode } from '../../types';

/**
 * Generates runner.js — the guard pipeline orchestrator.
 * Reads stdin from Claude Code, discovers guards, executes them,
 * auto-syncs inventory, updates memory, and reports results.
 */
export function generateRunner(mode: HooksMode): string {
  const isStrict = mode === 'yes';

  return `#!/usr/bin/env node
/**
 * runner.js — Guard Pipeline Orchestrator
 * Generated by AICodeSight. Executes composable guards in sequence.
 * Global mode: ${mode === 'yes' ? 'strict' : 'warning'}
 */
const fs = require('fs');
const path = require('path');

let input = '';
process.stdin.setEncoding('utf-8');
process.stdin.on('data', (chunk) => { input += chunk; });
process.stdin.on('end', () => {
  try {
    run(JSON.parse(input)).catch(e => {
      process.stderr.write('  [AICodeSight] Runner error: ' + e.message + '\\n');
      process.exit(0);
    });
  }
  catch (e) {
    process.stderr.write('  [AICodeSight] Error parsing stdin: ' + e.message + '\\n');
    process.exit(0);
  }
});
setTimeout(() => { process.stderr.write('  [AICodeSight] Timeout — no stdin received\\n'); process.exit(0); }, 5000);

async function run(context) {
  const toolName = (context.tool_name || '').toLowerCase();
  if (toolName !== 'write' && toolName !== 'edit') process.exit(0);

  const toolInput = context.tool_input || {};
  const filePath = toolInput.file_path || toolInput.filePath;
  if (!filePath) process.exit(0);

  const ext = path.extname(filePath).toLowerCase();

  // JSON format validation for AICodeSight config files (before source-code filter)
  if (ext === '.json') {
    try { validateCompactJsonFormat(toolName, toolInput, filePath); } catch {}
    process.exit(0); // JSON files never go through source code guards
  }

  if (!['.ts', '.tsx', '.js', '.jsx', '.cs'].includes(ext)) process.exit(0);

  const projectRoot = findProjectRoot(filePath);
  if (!projectRoot) process.exit(0);

  // Read current content, then simulate proposed changes
  let content;
  try { content = fs.readFileSync(filePath, 'utf-8'); }
  catch { content = ''; } // New file (Write to non-existing path)

  // Build proposed content: what the file WILL look like after the tool runs
  let proposedContent = content;
  if (toolName === 'write') {
    // Write replaces entire file
    proposedContent = toolInput.content || content;
  } else if (toolName === 'edit') {
    // Edit replaces old_string with new_string
    const oldStr = toolInput.old_string;
    const newStr = toolInput.new_string;
    if (oldStr != null && newStr != null && proposedContent.includes(oldStr)) {
      if (toolInput.replace_all) {
        proposedContent = proposedContent.split(oldStr).join(newStr);
      } else {
        proposedContent = proposedContent.replace(oldStr, newStr);
      }
    }
  }

  // Extract exports from the PROPOSED content (not current)
  const fileExports = extractExports(proposedContent, ext);
  // For Edit operations, also extract current exports to detect what's NEW vs pre-existing
  const currentExports = (toolName === 'edit' && content) ? extractExports(content, ext) : null;
  const claudeDir = path.join(projectRoot, '.claude');
  const inventory = loadJSON(path.join(claudeDir, 'inventory.json'));
  const config = loadJSON(path.join(claudeDir, 'hooks', 'guard-config.json')) || defaultConfig();
  const memory = loadJSON(path.join(claudeDir, 'hooks', 'guard-memory.json')) || { warnings: {}, lastUpdated: '' };
  const relativePath = path.relative(projectRoot, filePath).replace(/\\\\/g, '/');

  // Periodic inventory cleanup: remove entries for files deleted from disk
  if (inventory) {
    cleanupInventory(inventory, projectRoot, claudeDir);
  }

  const guardContext = {
    toolName, filePath, relativePath, content: proposedContent, fileExports,
    currentExports, inventory, config, memory, projectRoot, claudeDir, ext,
  };

  // Discover and run guards
  const guardsDir = path.join(claudeDir, 'hooks', 'guards');
  let guardFiles = [];
  try { guardFiles = fs.readdirSync(guardsDir).filter(f => f.endsWith('.js')).sort(); }
  catch { process.exit(0); }

  const allMessages = [];
  let shouldBlock = false;
  let suppressedCount = 0;
  let totalDetected = 0;

  for (const guardFile of guardFiles) {
    try {
      const guard = require(path.join(guardsDir, guardFile));
      const guardConf = config.guards[guard.name] || { severity: 'warn' };
      if (guardConf.severity === 'off') continue;

      const result = await Promise.resolve(guard.check(guardContext));
      if (!result || result.passed) continue;

      for (const msg of result.messages) {
        const effective = guardConf.severity === 'block' ? 'block' : (msg.severity || 'warn');
        const memKey = guard.name + ':' + (msg.identifier || msg.text);
        totalDetected++;

        // Memory-based throttling: show every Nth time after threshold (never fully suppress)
        const memEntry = memory.warnings[memKey];
        if (memEntry && memEntry.count >= 10 && effective !== 'block') {
          // After 10 occurrences, show every 5th time
          if (memEntry.count % 5 !== 0) {
            suppressedCount++;
            continue;
          }
        }

        allMessages.push({ ...msg, severity: effective, guard: guard.name, memKey });
        if (effective === 'block') shouldBlock = true;
      }
    } catch (e) {
      process.stderr.write('  [AICodeSight] Guard error in ' + guardFile + ': ' + e.message + '\\n');
    }
  }

  // Auto-sync inventory
  if (inventory && fileExports.length >= 0) {
    autoSyncInventory(inventory, relativePath, fileExports, proposedContent, claudeDir);
  }

  // Update memory (track ALL detected messages, not just shown ones)
  updateMemory(memory, allMessages, claudeDir);

  // Always provide feedback so user knows guards are running
  if (allMessages.length === 0) {
    if (suppressedCount > 0) {
      process.stderr.write('  [AICodeSight] ' + relativePath + ' — ' + suppressedCount + ' known warnings (throttled)\\n');
    }
    process.exit(0);
  }

  report(allMessages, relativePath, shouldBlock, suppressedCount);
  // Exit 2 = block in PreToolUse, Exit 0 = allow
  process.exit(shouldBlock ? 2 : 0);
}

function autoSyncInventory(inventory, relativePath, fileExports, content, claudeDir) {
  try {
    const lines = content.split('\\n').length;
    const existing = inventory.files.findIndex(f => f.path === relativePath);
    const entry = {
      path: relativePath,
      lines,
      exports: fileExports.map(e => ({ name: e.name, type: e.type, line: e.line })),
      classification: lines > 800 ? 'critical' : lines > 500 ? 'high' : lines > 350 ? 'medium' : 'ok',
      isGeneric: isGenericName(relativePath),
    };

    if (existing >= 0) {
      inventory.files[existing] = entry;
    } else {
      inventory.files.push(entry);
      inventory.stats.totalFiles++;
    }

    // Recalc stats
    let totalLines = 0, totalExports = 0;
    for (const f of inventory.files) {
      totalLines += f.lines;
      totalExports += f.exports.length;
    }
    inventory.stats.totalLines = totalLines;
    inventory.stats.totalExports = totalExports;
    inventory.generatedAt = new Date().toISOString();

    fs.writeFileSync(path.join(claudeDir, 'inventory.json'), JSON.stringify(inventory, null, 2), 'utf-8');
  } catch { /* non-critical, don't break the hook */ }
}

/**
 * Removes inventory entries for files that no longer exist on disk.
 * Throttled: only runs every 5 minutes to avoid fs.existsSync overhead.
 * Mutates inventory in-place — autoSyncInventory handles the write.
 */
function cleanupInventory(inventory, projectRoot, claudeDir) {
  try {
    const CLEANUP_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes
    const now = Date.now();
    const lastCleanup = inventory._lastCleanup ? new Date(inventory._lastCleanup).getTime() : 0;

    if (now - lastCleanup < CLEANUP_INTERVAL_MS) return;

    inventory._lastCleanup = new Date(now).toISOString();

    const before = inventory.files.length;
    inventory.files = inventory.files.filter(f => {
      const fullPath = path.join(projectRoot, f.path);
      return fs.existsSync(fullPath);
    });

    if (before !== inventory.files.length) {
      // Recalc stats — autoSyncInventory will also recalc, but this ensures
      // guards see accurate data even before autoSync runs
      inventory.stats.totalFiles = inventory.files.length;
      let totalLines = 0, totalExports = 0;
      for (const f of inventory.files) {
        totalLines += f.lines;
        totalExports += f.exports.length;
      }
      inventory.stats.totalLines = totalLines;
      inventory.stats.totalExports = totalExports;
    }
  } catch { /* non-critical */ }
}

function updateMemory(memory, messages, claudeDir) {
  try {
    const now = new Date().toISOString();
    for (const msg of messages) {
      if (!memory.warnings[msg.memKey]) {
        memory.warnings[msg.memKey] = { count: 0, lastSeen: '', files: [] };
      }
      const entry = memory.warnings[msg.memKey];
      entry.count++;
      entry.lastSeen = now;
    }
    memory.lastUpdated = now;

    // Prune old entries (>30 days)
    const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000;
    for (const [key, val] of Object.entries(memory.warnings)) {
      if (new Date(val.lastSeen).getTime() < cutoff) delete memory.warnings[key];
    }

    fs.writeFileSync(
      path.join(claudeDir, 'hooks', 'guard-memory.json'),
      JSON.stringify(memory, null, 2), 'utf-8'
    );
  } catch { /* non-critical */ }
}

function report(messages, relativePath, shouldBlock, suppressedCount) {
  const prefix = shouldBlock ? '[BLOCKED]' : '[GUARD PIPELINE]';
  process.stderr.write('\\n');
  process.stderr.write('  ' + prefix + ' AICodeSight guards — ' + relativePath + '\\n');

  // Group by guard
  const grouped = {};
  for (const msg of messages) {
    if (!grouped[msg.guard]) grouped[msg.guard] = [];
    grouped[msg.guard].push(msg);
  }

  for (const [guard, msgs] of Object.entries(grouped)) {
    for (const msg of msgs) {
      const icon = msg.severity === 'block' ? '✖' : msg.severity === 'warn' ? '⚠' : 'ℹ';
      process.stderr.write('  ' + icon + ' [' + guard + '] ' + msg.text + '\\n');
      if (msg.suggestion) {
        process.stderr.write('    → ' + msg.suggestion + '\\n');
      }
    }
  }

  if (suppressedCount > 0) {
    process.stderr.write('  (' + suppressedCount + ' additional warnings throttled)\\n');
  }
  process.stderr.write('\\n');
  if (shouldBlock) {
    process.stderr.write('  To continue: resolve blocking issues or adjust guard-config.json\\n\\n');
  }
}

function extractExports(content, ext) {
  const exports = [];
  if (ext === '.cs') return extractCSharpExports(content);
  const lines = content.split('\\n');
  const patterns = [
    { regex: /export\\s+(?:async\\s+)?function\\s+(\\w+)/, type: 'function' },
    { regex: /export\\s+class\\s+(\\w+)/, type: 'class' },
    { regex: /export\\s+type\\s+(\\w+)/, type: 'type' },
    { regex: /export\\s+interface\\s+(\\w+)/, type: 'interface' },
    { regex: /export\\s+(?:const|let|var)\\s+(\\w+)/, type: 'const' },
    { regex: /export\\s+enum\\s+(\\w+)/, type: 'enum' },
  ];
  for (let i = 0; i < lines.length; i++) {
    for (const { regex, type } of patterns) {
      const match = lines[i].match(regex);
      if (match) exports.push({ name: match[1], type, line: i + 1 });
    }
  }
  return exports;
}

function extractCSharpExports(content) {
  const exports = [];
  const lines = content.split('\\n');
  const patterns = [
    { regex: /^\\s*public\\s+(?:sealed\\s+|abstract\\s+|static\\s+|partial\\s+)*class\\s+(\\w+)/, type: 'class' },
    { regex: /^\\s*public\\s+interface\\s+(\\w+)/, type: 'interface' },
    { regex: /^\\s*public\\s+enum\\s+(\\w+)/, type: 'enum' },
  ];
  for (let i = 0; i < lines.length; i++) {
    for (const { regex, type } of patterns) {
      const match = lines[i].match(regex);
      if (match) { exports.push({ name: match[1], type, line: i + 1 }); break; }
    }
  }
  return exports;
}

function findProjectRoot(filePath) {
  let dir = path.dirname(path.resolve(filePath));
  const root = path.parse(dir).root;
  // Pass 1: prioritize .claude/inventory.json (AICodeSight root) over sub-package package.json
  let d = dir;
  while (d !== root) {
    if (fs.existsSync(path.join(d, '.claude', 'inventory.json'))) return d;
    d = path.dirname(d);
  }
  // Pass 2: fallback to nearest package.json
  d = dir;
  while (d !== root) {
    if (fs.existsSync(path.join(d, 'package.json'))) return d;
    d = path.dirname(d);
  }
  return null;
}

function isGenericName(filePath) {
  const base = path.basename(filePath, path.extname(filePath)).toLowerCase();
  const generics = ['utils','helpers','common','shared','misc','tools','lib','functions','utilities','helper','extensions','constants','globals'];
  return generics.some(g => base === g || base.startsWith(g));
}

function loadJSON(filePath) {
  try { return JSON.parse(fs.readFileSync(filePath, 'utf-8')); }
  catch { return null; }
}

/**
 * Validates compact JSON format for AICodeSight config files.
 * Blocks writes that compress (1 line) or pretty-print (thousands of lines)
 * capability-index.json, which must use one-entry-per-line serialization.
 */
function validateCompactJsonFormat(toolName, toolInput, filePath) {
  const baseName = path.basename(filePath);
  if (baseName !== 'capability-index.json') return;

  // Only validate files inside .claude/ directory
  const dir = path.dirname(filePath).replace(/\\\\\\\\/g, '/');
  if (!dir.includes('.claude')) return;

  // Load guard config to check severity
  const projectRoot = findProjectRoot(filePath);
  if (!projectRoot) return;
  const claudeDir = path.join(projectRoot, '.claude');
  const config = loadJSON(path.join(claudeDir, 'hooks', 'guard-config.json')) || defaultConfig();
  const guardConf = config.guards['json-format'] || { severity: 'block' };
  if (guardConf.severity === 'off') return;

  // Compute proposed content (same logic as main runner, self-contained for isolation)
  let proposed;
  if (toolName === 'write') {
    proposed = toolInput.content || '';
  } else if (toolName === 'edit') {
    let current = '';
    try { current = fs.readFileSync(filePath, 'utf-8'); } catch {}
    const oldStr = toolInput.old_string;
    const newStr = toolInput.new_string;
    if (oldStr != null && newStr != null && current.includes(oldStr)) {
      proposed = toolInput.replace_all
        ? current.split(oldStr).join(newStr)
        : current.replace(oldStr, newStr);
    } else {
      proposed = current;
    }
  }

  if (!proposed || proposed.length < 10) return;

  // Parse JSON
  let data;
  try { data = JSON.parse(proposed); } catch (e) {
    const isBlock = guardConf.severity === 'block';
    const prefix = isBlock ? '[BLOCKED]' : '[GUARD PIPELINE]';
    process.stderr.write('\\n  ' + prefix + ' AICodeSight json-format — ' + baseName + '\\n');
    process.stderr.write('  ✖ [json-format] Invalid JSON: ' + e.message + '\\n');
    process.stderr.write('    → Fix the JSON syntax error before writing\\n\\n');
    if (isBlock) process.exit(2);
    return;
  }

  // Only validate files with enough entries to check ratios
  if (!Array.isArray(data.entries) || data.entries.length < 5) return;

  const lines = proposed.split('\\n');
  const lineCount = lines.length;
  const entryCount = data.entries.length;
  const expectedLines = entryCount + 6; // header (4) + array markers (2)

  // Check 1: Compressed format (everything on 1-3 lines)
  if (lineCount < entryCount * 0.5) {
    const isBlock = guardConf.severity === 'block';
    const prefix = isBlock ? '[BLOCKED]' : '[GUARD PIPELINE]';
    const icon = isBlock ? '✖' : '⚠';
    process.stderr.write('\\n  ' + prefix + ' AICodeSight json-format — ' + baseName + '\\n');
    process.stderr.write('  ' + icon + ' [json-format] File appears COMPRESSED (' + lineCount + ' lines for ' + entryCount + ' entries)\\n');
    process.stderr.write('    → Required: compact format with one entry per line (~' + expectedLines + ' lines expected)\\n');
    process.stderr.write('    → Use the Edit tool to modify individual entries, not Write to rewrite the entire file\\n');
    process.stderr.write('    → Do NOT use JSON.stringify() or json.dump() — they destroy the compact format\\n\\n');
    if (isBlock) process.exit(2);
    return;
  }

  // Check 2: Pretty-printed format (each entry expands to ~8+ lines)
  if (lineCount > entryCount * 5) {
    const isBlock = guardConf.severity === 'block';
    const prefix = isBlock ? '[BLOCKED]' : '[GUARD PIPELINE]';
    const icon = isBlock ? '✖' : '⚠';
    process.stderr.write('\\n  ' + prefix + ' AICodeSight json-format — ' + baseName + '\\n');
    process.stderr.write('  ' + icon + ' [json-format] File appears PRETTY-PRINTED (' + lineCount + ' lines for ' + entryCount + ' entries)\\n');
    process.stderr.write('    → Required: compact format with one entry per line (~' + expectedLines + ' lines expected)\\n');
    process.stderr.write('    → Do NOT use JSON.stringify(data, null, 2) — keep each entry on a single line\\n');
    process.stderr.write('    → Run "aicodesight update" to regenerate with correct format\\n\\n');
    if (isBlock) process.exit(2);
    return;
  }
}

function defaultConfig() {
  return {
    mode: '${mode}',
    guards: {
      duplication: { severity: 'warn', fuzzyThreshold: 0.8 },
      size: { severity: 'warn', maxLines: 350, maxExports: 5 },
      convention: { severity: 'warn' },
      coherence: { severity: 'info' },
      dependency: { severity: 'off' },
      'structural-duplication': { severity: 'warn' },
      'semantic-duplication': { severity: 'off', similarityThreshold: 0.66, blockThreshold: 0.85 },
      'json-format': { severity: 'block' },
    },
    whitelist: [],
  };
}
`;
}
