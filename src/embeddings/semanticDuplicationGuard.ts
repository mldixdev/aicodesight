/**
 * @intent Generate semantic-duplication.js guard — detects semantically similar capabilities via BGE-small embeddings
 * @domain embeddings
 */

/**
 * Generates the semantic-duplication guard JS file.
 * Runtime logic: loads embeddings cache, embeds @intent of new file,
 * compares via cosine similarity, warns/blocks on high similarity.
 */
export function generateSemanticDuplicationGuard(): string {
  return `/**
 * semantic-duplication.js — Guard: Semantic duplication via embeddings
 * Generated by AICodeSight.
 *
 * Compares the @intent of new files against the capability-index
 * using BGE-small-en-v1.5 embeddings and cosine similarity.
 *
 * Requires:
 *   - .claude/embeddings-cache.json (generated by aicodesight update)
 *   - @xenova/transformers (npm install -D @xenova/transformers)
 *
 * Configuration in guard-config.json:
 *   "semantic-duplication": {
 *     "severity": "off",            // "off" | "warn" | "block"
 *     "similarityThreshold": 0.66,  // warn threshold
 *     "blockThreshold": 0.85        // block threshold
 *   }
 */
const fs = require('fs');
const path = require('path');

// Singleton: model loaded once per process (hook invocation)
let _extractor = null;
let _extractorPromise = null;

async function getExtractor() {
  if (_extractor) return _extractor;
  if (_extractorPromise) return _extractorPromise;
  _extractorPromise = (async () => {
    const { pipeline } = await import('@xenova/transformers');
    _extractor = await pipeline('feature-extraction', 'Xenova/bge-small-en-v1.5');
    return _extractor;
  })();
  return _extractorPromise;
}

function cosineSimilarity(a, b) {
  let dot = 0;
  for (let i = 0; i < a.length; i++) dot += a[i] * b[i];
  return dot; // Vectors are pre-normalized, dot product = cosine similarity
}

function extractIntent(content) {
  // Look for @intent tag in comments
  const intentMatch = content.match(/@intent\\s+(.+?)(?:\\n|\\r|\\*\\/)/);
  if (intentMatch) return intentMatch[1].trim();
  return null;
}

function buildFallbackIntent(filePath, fileExports) {
  const baseName = path.basename(filePath, path.extname(filePath));
  if (fileExports && fileExports.length > 0) {
    const mainExport = fileExports[0];
    return baseName + ' — ' + mainExport.name + ' (' + mainExport.type + ')';
  }
  return baseName;
}

function appendLog(claudeDir, entry) {
  try {
    const logPath = path.join(claudeDir, 'hooks', 'semantic-guard-log.jsonl');
    fs.appendFileSync(logPath, JSON.stringify(entry) + '\\n', 'utf-8');
  } catch { /* non-critical */ }
}

module.exports = {
  name: 'semantic-duplication',

  async check(ctx) {
    const messages = [];

    // 1. Early exit: only Write (new file creation)
    if (ctx.toolName !== 'write') return { passed: true, messages: [] };

    // 2. Only source files
    if (!['.ts', '.tsx', '.js', '.jsx', '.cs'].includes(ctx.ext)) {
      return { passed: true, messages: [] };
    }

    // 3. Only NEW files (doesn't exist on disk yet)
    if (fs.existsSync(ctx.filePath)) return { passed: true, messages: [] };

    // 4. Skip .claude/ directory
    if (ctx.relativePath.startsWith('.claude/') || ctx.relativePath.startsWith('.claude\\\\')) {
      return { passed: true, messages: [] };
    }

    // 5. Skip excluded patterns (same as intent-declaration)
    const baseName = path.basename(ctx.filePath, ctx.ext);
    if (baseName === 'index' || baseName === 'barrel') return { passed: true, messages: [] };
    if (baseName.endsWith('.test') || baseName.endsWith('.spec')) return { passed: true, messages: [] };
    if (baseName.endsWith('.types') || baseName.endsWith('.d')) return { passed: true, messages: [] };
    if (baseName.endsWith('.config')) return { passed: true, messages: [] };

    // 6. Load embeddings cache
    const cachePath = path.join(ctx.claudeDir, 'embeddings-cache.json');
    let cache;
    try {
      cache = JSON.parse(fs.readFileSync(cachePath, 'utf-8'));
    } catch {
      // No cache — skip silently
      return { passed: true, messages: [] };
    }

    if (!cache.entries || cache.entries.length === 0) {
      return { passed: true, messages: [] };
    }

    // 7. Load @xenova/transformers
    let extractor;
    try {
      extractor = await getExtractor();
    } catch {
      appendLog(ctx.claudeDir, {
        ts: new Date().toISOString(),
        file: ctx.relativePath,
        intent: null,
        matches: [],
        action: 'skip',
        reason: 'transformers-unavailable',
      });
      return { passed: true, messages: [] };
    }

    // 8. Extract intent text
    let intentText = extractIntent(ctx.content);
    const fallback = !intentText;
    if (!intentText) {
      intentText = buildFallbackIntent(ctx.filePath, ctx.fileExports);
    }

    // 9. Compute embedding for the query
    const output = await extractor(intentText, { pooling: 'mean', normalize: true });
    const queryEmbedding = Array.from(output.data);

    // 10. Compare against cache
    const guardConf = ctx.config.guards['semantic-duplication'] || {};
    const similarityThreshold = guardConf.similarityThreshold || 0.66;
    const blockThreshold = guardConf.blockThreshold || 0.85;

    const matches = [];
    for (const entry of cache.entries) {
      const sim = cosineSimilarity(queryEmbedding, entry.embedding);
      if (sim >= similarityThreshold) {
        matches.push({
          name: entry.name,
          file: entry.file,
          description: entry.description,
          sim: Math.round(sim * 1000) / 1000,
        });
      }
    }

    // Sort by similarity descending
    matches.sort(function(a, b) { return b.sim - a.sim; });

    // 11. Determine action
    let action = 'pass';

    for (const match of matches) {
      if (match.sim >= blockThreshold) {
        action = 'block';
        messages.push({
          severity: 'block',
          identifier: 'semantic-dup:block:' + match.name,
          text: 'High semantic duplication (' + (match.sim * 100).toFixed(0) + '% similar) with ' + match.name + ' in ' + match.file,
          suggestion: 'Reuse ' + match.name + ' from ' + match.file + ' instead of creating a duplicate',
        });
      } else if (match.sim >= similarityThreshold) {
        if (action !== 'block') action = 'warn';
        messages.push({
          severity: 'warn',
          identifier: 'semantic-dup:warn:' + match.name,
          text: 'Semantic similarity (' + (match.sim * 100).toFixed(0) + '%) with ' + match.name + ' (' + match.description + ') in ' + match.file,
          suggestion: 'Check if ' + match.name + ' already covers this functionality before creating a new file',
        });
      }
    }

    // 12. Log every activation (pass, warn, block)
    appendLog(ctx.claudeDir, {
      ts: new Date().toISOString(),
      file: ctx.relativePath,
      intent: intentText,
      fallback: fallback,
      matches: matches.slice(0, 5), // Top 5
      action: action,
      threshold: similarityThreshold,
    });

    return { passed: messages.length === 0, messages };
  },
};
`;
}
